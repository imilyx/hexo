---
title: 毛营游记
date: 2021-08-24 07:35:40
tags:
    - 游记
mathjax: true
---

铁头娃 xml 被虐杀记录

## 前言

hhz：我们学校有 1 个 3 人队和 3 个 1 人队

除我皆为神仙（报名时因为 CF 没上橙还差点被劝退 /dk

## $\mathcal{8.23}$
---

solved：$\mathrm{A}$ $\mathrm{B}$ $\mathrm{D}$ $\mathrm{E}$ $\mathrm{F}$ ($5/12$)

### $\mathrm{C}$

你但凡多思康那么一下子…… 显然如果两个不同位置的长度大于 2 的串相等，它们头两个字符一定相同，这是非常有效的剪枝。

这还不够，你钦定这个方阵形如：
```
axaxaxaxaxaxa
xbxbxbxbxbxbx
...
mxmxmxmxmxmxm
```

显然一定有解。（膜拜万姥爷，直接手玩！

$n = 13$ 跑的飞快，$n = 14$ 就卡死了？据说理论极限是 $\sqrt{\frac{676}{2}} \approx 18$

### $\mathrm{D}$

$n$ 是偶数直接分两组。讨论 $n$ 为奇数的情况

设分了 $B$ 组，证明一定存在一种合法方案使得 $B =$ $n$ 的最小质因子

我们画个 $(n / B) * B$ 的表格，每列为一个组。将 $n$ 个数按大小划为 $n / B$ 个组。这里把第 $k$ 个奇数就写作 $k$，显然对每列的总和没有影响。

- $n / B$ 为偶数：直接一行单调增，一行单调减
- $n / B$ 为奇数：最后三行拎出来做，第一行单调增，第二行把一个单调增的序列后 $\lfloor \frac{B}{2} \rfloor$ 个数拎到开头，第三行相当于填平前两行造成的列间差异，随便做一下。

~~听说万姥爷暴搜过 $2e5$~~

### $\mathrm{E}$

设 $d_i = (\sum\limits_{j \leq i} a_j) + c_i$，$e_i = (\sum\limits_{j \leq i} a_j) - b_{i + 1}$，那么

$$
f(X) = \min\limits_{0 \leq i < r} \left\{ d_{s_{i + 1} - 1} - e_{s_i - 1} \right\}
$$

二分，从后往前（从前往后也可以）如果一个位置 $i$ 作为分割点满足 $[i, n)$ 合法（每段权值大于等于二分值）就把 $d_{i - 1}$ 丢进 set；check 某个点 $i$ 能否作为分割点就看 set 中最大元素 $- e_{i - 1}$ 是否大于等于二分值。

xml 这个 sb 头三发实现了一个相当于「只查询 max」的 set，T 哭了……

### $\mathrm{F}$

~~听说是某「ZROI 提高组十联测」原题~~

sb 题啊，首先你能根据性质想象树的形状。对于某个位置 $(i, j)$，假设所有 $x + y < i + j$ 的点都在树里，它的上边和左边一定有一个选，即贡献和为 $(ans = \sum\limits_{i = 1}^{m - 1} a_1 + b_j ) + (\sum\limits_{i = 1}^{n - 1} a_i + b_1) + (\sum\limits_{i = 2}^n \sum\limits_{j = 2}^n \min(a_{i - 1} + b_j, c_i + d_{j - 1}))$，最后一部分选 $ab$ 组合当且仅当 $a_{i - 1} - c_{i} < d_{j - 1} - b_j$，枚举 $i$，$d_{j - 1} - b_j$ 存起来排序后记录 $b$ $d$ 前缀和，二分。

最后写完整个人都瘫了，太累了

### $\mathrm{G}$

完蛋，特喵的读错题了，是要*操作过程也算上*的本质不同！

将 $1/m$ 视为间隔点，间隔点之间的元素视为过渡元素

设 $rest$ 为剩余的可添加过渡元素数量

相当于有三种操作：

- $\mathrm{I}$ ：加一个与当前末尾间隔点同色的间隔点, $rest$ 不变
- $\mathrm{II}$ ：加一个与当前末尾间隔点异色的间隔点, $rest += m - 2$
- $\mathrm{III}$ ：加一个过渡元素，$rest -= 1$

相当于统计本质不同「终点不低于 $0$」折线图

预处理, $dp[x, y]$ 表示已出现 $x$ 个 $m + 2$ 和 $y$ 个 $-1$ 的本质不同折线图数

枚举 $\mathrm{II} + \mathrm{III}$ 个数 $k$，$ans = \sum\limits_k \sum\limits_{x + y = k} dp[x, y]$

### $\mathrm{H}$

## $\mathcal{8.24}$
---

### $\mathrm{A}$

300iq 知道自己这道妙题被小常数 $n^2$ 暴力艹过去了吗（

递归。划分为两部分，一部分是有 $2^i$ 的（设为 $x$），另一部分没有 $2^i$（设为 $y$）

显然 $x$ 中每个数 $- 2^i$ 都在 y 中（「子集都在」的性质）

设 $x'$ 表示 $x$ 中每个数 $- 2^i$ 后的集合

根据「$x'$ 自我匹配」和「$y$ 自我匹配」的答案，推出「$x$ 和 $y$」匹配的答案。

具体来说，将 $x'$ 指向自己的边指向 $y$ 中对应数，$y$ 指向 $y$ 中 $x'$ 部分的边指向 $x$ 中对应数（即 $+ 2^i$），这样避免了 $x$ 指向自己。

### $\mathrm{C}$

二分 + bfs判断。

xml tmd WA on 19，调了三小时，原来是二重循环只 break 了一重

### $\mathrm{E}$

好诶，计数题！

首先你把它翻折，即 $s_1 s_n s_2 s_{n - 1} \cdots$

一个合法的方案是，划分为若干偶长度回文串并填数，最后一段任意填

$n^2$ $9e8$，$8s$，有意思吗（

### $\mathrm{H}$

口胡以示敬意，写起来真的恶心

以下的删边，无特殊说明皆为：若不是特殊边，则仅删去这条边，否则删去这条边以及这条边的两个端点。

首先对于一个点若连接的特殊边条数 $\geq 3$ 直接可以弃了。

剩下一些特殊边构成的链或环（作为独立连通块），环就直接输出了，链可以缩起来，这样处理完后图上所有特殊边都不相邻。

环一定在边双中！枚举删边，直到只剩一个环即可。证明我觉得不太必要啊 TAT……

### $\mathrm{I}$

造 $g$ 棵树，在每棵树覆盖自己负责的那块区域外，还要求覆盖整张图的最小代价

利用拟阵对最优化的解释，从小到大枚举边，check 能否加入，具体来说看

1. 加的两个端点是否已经连通
2. 加边后是否会造成两个 guard 争夺一些位置的情况。即，「guard 和 连通块」这张 二分图 的最大匹配中是否每个 guard 都匹配了一个连通块

最终森林中的边一定都是 MST 上的，需要 check 的边数 $n^2 \rightarrow n$

---

妈妈我终于 A 了 (;´༎ຶД༎ຶ`)

匈牙利？网络流！似乎是 $O(n * n^3 \sqrt{n})$ 的但跑的比 $O(n * n^3)$ 的匈牙利快（当然要加当前弧优化
puts("-1") 在最开头判一次

以后判无解都最开头判一次结尾判一次！！！

### $\mathrm{L}$

C 和 L 真是把我心态搞炸了。

思路是很简单的最短路计数，每个点维护一个 $\mathrm{pair}$，$<dis, -num>$，表示从起点到该点的最优路径的距离和符合的日志数（为了方便比大小，第二维设为相反数

结果 tmd 前驱忘记继承了。即，从 $x$ 转移到 $y$，若 $pre[x]$ 已为 $-1$，$pre[y]$ 就不能为 $x$ 而是也要为 $-1$，这样才好直接根据 $pre[n]$ 判断是否输出 $1$。

## $\mathcal{8.25}$
---

### $\mathrm{A}$

设 $x = \mathrm{AND}_{i = 1}^{n} a_i$，输出形如 $a_1, x, a_2, x \cdots, x, a_n$，特判 $n = 1, 2$

### $\mathrm{B}$

$$
\lfloor \frac{b_i i^k}{w} \rfloor = \frac{ b_i i^k - (b_i i^k) \bmod w }{w}
$$

要求 $\sum\limits_{i = 1}^n b_i i^k$ 和 $\sum\limits_{i = 1}^n (b_i i^k) \bmod w$

发现值域很小，考虑建立**权值**线段树。

带取模的这个东西维护非常套路。SGT 每个节点 $cnt[x, y]$ 表示这个区间内 $b_c \bmod w = x$, $c \bmod w = y$ 的个数，**$y$ 是以该区间左端点为 $1$ 开始数起的**，这样，删点加点对排名的影响就很好处理了，合并儿子的时候根据左儿子的 $size$ shift 一下即可。

再来考虑维护第一个。还是考虑合并 shift，相当于要支持快速计算

$$
\sum\limits_{b_i \in [l, r]} b_i (rk_i + shift)^k \\
= \sum\limits_{b_i \in [l, r]} \sum\limits_{j = 0}^k b_i \binom{k}{j} rk_i^j shift^{k - j} \\
= \sum\limits_{j = 0}^k \binom{k}{j} shift^{k - j} \sum\limits_{b_i \in [l, r]} b_i rk_i^j \\
$$

其中 $rk_i$ 是 $b_i$ 在 $[l, r]$ 区间内的排名，这样设定也是为了处理删加点对排名的影响，方便合并 shift。对每个区间维护 $\sum\limits_{b_i \in [l, r]} b_i rk_i^j$ 即可。

### $\mathrm{D}$

朴素的区间 dp 是 $O(n^3)$ 的。

考虑二分，每次把能扩展到的扩展了

吸收二分的想法，考虑能否只用 $\leq$ 某个数的操作完成任务，于是按权值从小往大转移，每次在确定一个区间合法后把能扩展到且未标记的都标记为当前权值。

比如已确定 $[l, r]$，有两种转移：

- 转移给 $dp[l - 1, r + 1]$，条件是 $dp[l - 1, r + 1]$ 未标记且 $cost[l - 1, r + 1] < dp[l, r]$ $(\mathrm{I})$
- 1. 转移给 $dp[l, k]$ $(k > r)$，条件是 $dp[l, k]$ 未标记且 $dp[r + 1, k]$ 已标记 $(\mathrm{II}-1)$
  2. 转移给 $dp[k, r]$ $(k < l)$ ，条件类似上面 $(\mathrm{II}-2)$

值得注意的是每个区间 $[l, r]$ 除了上面这两大种**被**转移到的方式，还剩一种是 $cost[l, r] > dp[l + 1, r - 1]$ 且 $[l + 1, r - 1]$ 已经标记 $(\mathrm{III})$

优化 $\mathrm{II}$ 的 DS 是「the best structure in the world」——bitset！
对于每个位置，分别存下以它为左端点和右端点，未标记和已标记的区间的右端点，然后你只需要做区间 $\mathrm{and}$！

复杂度：借助 bitset 实现每个区间只入队一次，但是实现转移二需要做 $\mathrm{and}$ 是 $\frac{n}{\omega}$ 的，因此总复杂度 $O(\frac{n^3}{\omega})$

实现细节：别用值域 vector 存每个区间，排序来的快得多。

### $\mathrm{E}$

正解竟是随机化…… 早该想到的，没有靠谱解法就应该考虑随机化减小错误概率嘛

先询问全集边数。

随机分为两个点集，两次询问 check 点集之间的边是否为偶数，若整张图存在度数为奇的点，有 $\frac{1}{2}$ 的概率会判对。因为考虑将一个奇数点移到对面集合，边数会改变，奇组合数之和比偶组合数之和为 $\frac{1}{2}$。

做 $29$ 次。判错的概率为 $\frac{1}{29}$。共 $2 * 29 + 1 = 60$ 次询问。

高啊…… 我就是不会概率的屑

### $\mathrm{F}$

「二元不好处理就用 $a$ 表示 $b$」

具体来说你把 $a, b, c, d$ 除以 $a + b$ 肯定没有问题。

然后就是 $(a, 1 - a)$ 变为 $(2a, 1 - 2a)$ 还是 $(2a - 1, 2(1 - a))$ 的问题

你发现第二维根本不用去管。所以问题就变成 $a$ 每次变成 $2a$ 或 $2a - 1$，最少几次变成 $c$。

可以看范围，$k$ 次操作后变到 $[2^k a - (2^k - 1), 2^k a]$，由于 $k \geq 30$ 一定全覆盖，从小到大枚 $k$ 即可。

其实「$p \nmid (a + b)$」就在暗示了。

### $\mathrm{G}$

看官解，有六种结构 $x_1$ ~ $x_6$。要求 $x_6 - x_2$。

原理是用奇怪的容斥完成这个。

虽然 note 说不要当成 black magic，但我不会用容斥解释这个东西啊……

### $\mathrm{H}$

大方向是对的…… 一直在凑一个表达式，能够覆盖 $21$ ~ $60$，试了几种都 GG，就绝望了

原因是我构造的都是蝴蝶结模型，然而你不用把两边断开，所以实际上是个奶嘴模型（？）

先判掉 $K \leq 20$

选 $n$ $(n \geq 3)$ 个点做团，$m$ $(m \geq 2)$ 个点做链，链接到团上，贡献是 $\binom{n}{2} - 1 + (m - 1) + 2(n - 1)$

### $\mathrm{J}$

题意真是有够绕的

考虑首先把 $p$ 排序。然后停止了思考。

#### $\mathscr{Part}$ $1$

假设 $q$ 已确定

把 $a$ 所有位置间的小于号看作有向边，生成 $s$ 合法当且仅当，这张 $2n$ 个点的图中无环。

显然存在环一定存在大小为 $4$ 的环。证明考虑两行各自内部是不会有环的，搞事情的边只能出现在两行之间，
形如
```
<<<<<<
v    ^
>>>>>>
```
的结构，中空部分的边不论是往上还是往下都会构成一个更小的环。

考虑 $q$ 中最大元素的位置 $i$，

- 若 $s_i = 0$，则对 $j > i$ 无限制，因为 $q$ 中不存在比 $q_i$ 大的元素所以 $(1, i) \rightarrow (2, i)$ 一定不会出现在任何一个四元环中，直接删除
- 若 $s_i = 1$，则对 $j > i$，$a_{1, j} > a_{1, i} > a_{2, i} > a_{2, j}$, 即对 $j > i$ 有限制 $s_j = 1$，相当于删 $i$ 及其右边所有位置

「删除操作序列集合」和「$s$ 集合」构成双射，「删除操作序列集合」和「$q$ 的上升子序列集合」构成双射，因此等价于数所有 $q$ 的上升子序列数和。

#### $\mathscr{Part}$ $2$

大方向是统计「枚举子序列中已确定的位置，在之间选若干未确定位置填数使得子序列上升」的方案数之和。

先预处理出每个值域区间有多少个数是未出现在给定 $q$ 里的，记为 $free[l, r]$

以「已确定的 $q_i$」作为分界点。转移：比如从 $q_l$ 到 $q_r$，$[l + 1, r - 1]$ 之间选若干未确定 $q$ 填 $free[q_l + 1, q_r - 1]$ 里的数。

### $\mathrm{M}$

$x^2 + y = z^2$，则 $y$ 一定形如 $(2x + 1) + (2(x + 1) + 1) + \cdots$

毛估估觉得表示成连续奇数的方式在 $10^6$ 以内很少，全部找出来就好了

官解说，$(z + x)(z - x) = y$，设 $a = z + x, b = z - x, ab = y \leq 1e6, \frac{a - b}{2}$ 在数组里。直接枚举就是调和级数复杂度。（md 挂在最后一步上了

## $\mathcal{8.28}$
---

### $\mathrm{A}$

没脑子选手直接从大到小加，BIT 维护

### $\mathrm{B}$

首先 $gcd(p, q) > 1$ 时一定无解，所以只讨论 $gcd(p, q) = 1$

注意到 $+p$ 行为和 $-q$ 行为在模 $p + q$ 意义下等价

设 $V_i$ 表示 $0$ ~ $n - 1$ 中 $\bmod (p + q) = i$ 的点数，你发现实际上只有三种合法 case：全相等、有一个 $V$ 多 $1$、有一个 $V$ 少 $1$，其余所有都是不！合！法！的！

很好做。以「全相等」为例，以 $p - 1$ 为起点，跳完所在环后应当在 $p + q - 1$，此时跳一步到达 $(p + q) + (p - 1)$ 开始新环的奇妙旅程。其他 case 就换一下起点的事情。

### $\mathrm{C}$

好诶，计数题！

别读错了，贡献是*相邻对*产生的。

枚举 $i$ 与 $j = nxt(i)$ 的贡献，

$$
= \sum\limits_k P(f(s_i) = k) \cdot P(f(s_j) = k)
$$

一个长度为 $n$ 的串 $s$，

$$
P(f(s) = k) = \frac{1}{26^{n}} {\sum\limits_{d \mid a_i, d \geq k} \frac{g(d)}{d}}
$$

其中 $g(d)$ 是长度为 $d$ 的本质不同**非**循环串个数。除以 $d$ 是因为字典序最小处在 $k$ 的比例占 $\frac{1}{d}$。

计算 $g$ 需要莫反：

$$
\sum\limits_{d \mid n} g(d) = 26^n \\
g(n) = \sum\limits_{d \mid n} 26^d \mu(\frac{n}{d})
$$

带入原式

$$
= \frac{1}{26^{a_i + a_j}} \sum\limits_{k} \sum\limits_{d \mid a_i, d \geq k} \frac{g(d)}{d'} \sum\limits_{d' \mid a_j, d' \geq k} \frac{g(d')}{d'} \\
= \frac{1}{26^{a_i + a_j}} \sum\limits_{d \mid a_i, d \geq k} \frac{g(d)}{d'} \sum\limits_{d' \mid a_j, d' \geq k} \frac{g(d')}{d'} \min(d, d')
$$

$x$ 的约数个数是 $\sqrt{x}$ 级别的（而且十分不满）前缀和 + 指针，随便算一下就好了

### $\mathrm{E}$

~~考虑从大到小加数。计算贡献就枚举。~~ 不行啊不行这是 $nmn^2$ 的

不争气的看了题解。

显然可以枚举矩阵上下界，枚举当前最小数在哪列，记录往两边扩展的最大距离，单调栈即可

## *离谱事件*

xml 没看到 Gmail 上发的「Replacement Contest」

## $\mathcal{8.30}$
---

### $\mathrm{H}$

要被 xml 蠢哭了 TAT

$x < y$ ！所以如果 $y \mid n$ 一定不存在入边，否则有恰好一条入边，$x = y - (n \bmod y)$

大的位置只能往小了走，因此不断减大的那个即可。数据随机所以不会太慢。

### $\mathrm{I}$

就是个简单 dp 啊你想复杂了。

$dp[i, j]$ 表示用前 $i$ 个步骤到离 bar 距离为 $j$ 的位置*至少一次*的概率，$ans = 1 - \frac{1}{2n + 1} \sum\limits_{i = -n}^n (1 - dp[n, i])$