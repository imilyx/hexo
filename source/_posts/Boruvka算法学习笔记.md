---
title: 'Boruvka算法学习笔记'
date: 2020-08-01 10:12:40
tags: 
    - 最小生成树
mathjax: true
---

$\sout{Boruvka?\ Bvrouka??\ Brouvka???}$

$Boruvka$ 是一个古老的最小生成树算法，综合了 $Kruskal$ 和 $Prim$.（我觉得更像是进阶版 $Prim$）

它的算法流程是：初始时每个节点都是一个连通块，每次从**每个**块伸出去一条最短边，然后把新形成的连通块缩成一个新的块。每次 块个数至少减半，所以时间复杂度是 log 的。算法正确性可以参考 $Prim$ 的，相当于每次扩展多棵子树。

B **合并只有 log 次**，这是 K 和 P 做不到的。

通常它作为一种**思想**会很有用，比如**位运算生成树**的题。

## $[CF888G]$
-----

题意：边 $<i, j>$ 边权为 $a_i\ XOR\ a_j$ 的最小生成树

考虑 $Trie$ 树，共有 $n - 1$ 个 $LCA$（$n - 1$ 个有两个儿子的节点）

根据 B 算法的**思想**，（将每个子树视为一个块），容易发现若 $x$ 同时有 $0/1$ 子树，两个子树就会连边

遍历 $Trie$ 树，在每个 $LCA$ 处做启发式合并、查左右子树连边的最小值

## $[CF1305G]$
-----

题意：连边 $<i, j>$ 规则为 $a_i\ AND\ a_j = 0$ 的最大生成树

注意到这是一棵树，且它的特性在于，每个点的入度仅为 1.

于是有个很妙的方法：将每条边权值改为 $a_i + a_j$，最终答案是边权和 $- \sum{a_i}$，那么答案就转化成最大生成树。

$boruvka$ 算法直接做，每一轮子集 dp 维护出每个二进制集合内最大和次大的点权，**两个点所在集合不同**，这样查询的时候查询补集，就算最大的点权和当前点在同一集合里，也能“撞”掉，选到次大点。可以用 pair 记录 <点权，集合的id>。

$O(2^{18} * 18 * logn)$

## $[UOJ176]$
-----

题意：边 $<i, j>$ 边权为 $a_i\ AND\ a_j$ 的最大生成树

