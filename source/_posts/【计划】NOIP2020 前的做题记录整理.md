---
title: 'NOIP2020 前的做题记录整理'
date: 2020-12-05 23:58:59
tags: 
mathjax: true
---

NOIP 前也做了不少好题！但是依然考的那么差。。。QAQ 每道题都很好！但太难了都没做太深入的思考 QAQ。。。所以接下来到 NOIP2021 的 300 多天要尽可能争取完整的做出题。

# 立下 Flag（希望它永远不倒）：每天都自己独立做出一道有质量的题

### [$ZJOI2019-麻将$](https://loj.ac/p/3042)
---

$dp$ 套 $dp$ 就是状态间的转移也有 $dp$ 关系，$f[i]$ 转移到 $f[j]$, $i$ 和 $j$ 有 dp 关系。所以要 $dp$ 预处理状态和状态的转移边。（这不就是自动机嘛？）

我们需要对子数和面子数来表示摸出的牌的状态。

刻子用到的是同种牌，所以可以转移时枚举个数，不用表示到状态里因为对后续无影响。

对后续有影响的就是顺子。
$f[i, 0/1, j, k]$ 表示考虑到第 $i$ 种牌，是否有过对子，我决定分出的 $(i - 1, i, i + 1)$ 型的顺子个数为 $j$，我决定分出的 $(i, i + 1, i + 2)$ 型的顺子个数为 $k$，此时已经凑出的最大面子数。
于是转移到 $i + 1$ 的时候 $j + k$ 张和之前的组顺子（此时有 $j$ 个面子诞生了）
$j$, $k$ 必然不会大于 2 否则就是三张刻子（数量相等的情况下优先凑刻子）
发现用 $cnt$（对子个数）和 $f[0/1, j, k]$ 就可以表示状态。

因为你发现这就是个在状态间不断转移的跳 $n$ 步的东西，所以可以命名为“麻将自动机” 2333！
自动机上的节点表示的状态就是把 $cnt$ 和 $[0/1, j, k]$ 压在一块
参照在 $AC$ 自动机上 $dp$ 的套路，我们敲定最终 $dp$ 状态：$f[i, j, k]$ 表示考虑到第 $i$ 种牌，在自动机上第 $j$ 个节点，共摸了 $k$ 张牌的方案数

根据期望的线性性和整数概率公式，我们可以把答案拆分为 $P$ 的权值的每个 $1$ 对答案的贡献，即每个时刻没胡牌的方案数 $*$ 概率。
那个方案数直接取自动机上的就好，因为能待在自动机上的就一定没胡。

仔细想想好像之前写的两道 $dp$ 套 $dp$ 也很自动机啊。

[$Code$](https://loj.ac/s/1005925)

### [$LOJ3280-首都城市$](https://loj.ac/p/3280)
---

考虑选颜色 a 会让颜色 b 也必选，不妨 a -> b 连边。但是颜色 -> 颜色连边不容易，考虑让点作为中转站，颜色 -> 点 (可以通过树上倍增优化建图) 再 点 -> 颜色。

[$Code$](https://loj.ac/s/1006784)

### [$CF673F-Bearish Fanpages$](https://www.luogu.com.cn/problem/CF643D)
---

~~嘟嘟~~读懂题意你就会发现这是道模拟题。因为根据老套路，修改只要改对父亲的，父亲对儿子的查询时加上。（所以它为什么黑了啊？

这题巨烦奥！一个点的度数影响它的儿子，它的父亲，它自己

```
x -> f -> ff -> fff
    son   son   son
    val   val
    deg
（下面是影响的东西）
```

但是怎么处理父亲度数变了，儿子在全局 set 里的变化呢？我们对每个点开一个 set，维护其儿子集合的最大最小权值。所以全局 set 其实装的就是每个 set 的最大最小权值。

[$Code$](http://codeforces.com/contest/643/submission/100179942)

### [$CF806D-Perishable Roads$](https://www.luogu.com.cn/problem/CF773D)
---

首先会想到贪心的把点都挂到最短边的一端，像个扫帚。但这是有问题的：如果最短边与根不直接相连，有些点就处于根到最短边的路径上，没法挂过去。

将除了最短边外的所有边权值减去最短边权值，跑根到最短边的最短路就好。

### [$LOJ3385-Svjetlo$](https://loj.ac/p/3385)
---

被出到模拟赛里了。考场上我的 dp 状态是 $f[x, 0/1, 0/1]$ 表示 $x$ 回不回来，$x$ 当前的颜色。然而巨难写！（而且还是错的。正解 $f[x, 0/1/2, 0/1]$ 表示 x 子树内的路径接口状态和 x 当前的颜色。
```
f 的定义是 包括起始点，也包括终点。
0: ⬇️⬆️  1: ⬆️或⬇️  2: ⬆️⬇️
```
这种状态设计是怎么想到的呢？
一条路径，由：⬆️ / ⬇️⬆️ / ⬇️ 三部分组成，其中一和三都最多只有一个；为了方便讨论，我们规定单个点也可以看作 ⬆️ 或 ⬇️。dp 就可以像背包一样做了。

[$Code$](https://loj.ac/s/1003823)

### [$LOJ3370-Histogram$](https://loj.ac/p/3370)
---

还是模拟赛题 QAQ（口胡差点正确！耶！

我口胡的是按 $a$ 降序分治（就是笛卡尔树），每个块用两个线段树维护两个单调栈然后上线段树合并，但那样好像有亿点蛋疼（因为笛卡尔树分治 $n$ 次，单次查询 & 合并只能是 $log$ 级别的

正解就是简单粗暴，每次把区间划两半的分治，计算跨中点的区间贡献。

讨论 $a$ 和 $b$ 最小值同在一边和不在一边两种情况。同在一边是有单调性的，直接双指针。不在一边的话就要麻烦一些：考虑 $b$ 最小值在左边，现在要在右边找一个 $a$ 最小值。

设 $r_1$ 比 $r_2$ 优，则 $a[r_1] * b * (r_1 - l + 1) \geq a[r_2] * b * (r_2 - l + 1)$
化成斜率优化的柿子就是 $(a[r_2] * (r_2 + 1) - a[r_1] * (r_1 + 1)) / (a[r_2] - a[r_1]) \geq l$，而 $l$ 单调递减。

线段树维护凸包就可以支持区间查询啦！$O(n log^2 n)$ 因为有 $logn$ 个区间，每个区间要 $logn$ 凸包查询

[$Code$](https://loj.ac/s/1004609)

### [$JOI2020-汉堡肉$](https://loj.ac/p/3272)
---

很妙啊！（$K \geq 4$ 就是人类智慧题

首先四个签只会出现在四条线上：$max(L)$, $min(R)$, $max(D)$, $min(U)$。

证明：
1. $max(L) \leq min(R)$, $max(D) \leq min(U)$，只要往围成的矩形里插一根签
2. $max(L) > min(R)$, $max(D) \leq min(U)$，$max(L)$ 右边必然有签，$min(R)$ 左边必然有签，并且两边的签通过平移都可以移动到两条线上。另一种相反情况也如此。
3. $max(L) > min(R)$, $max(D) > min(U)$，道理同上。

证毕。

$max$ 和 $min$ 非常好，为什么？以 $max(L)$ 为例分析，首先它右边必定要有签，在有签的情况下这签尽量左又是最优的，而竖直方向对它无影响因为已经是 $max$ 了。

$K \leq 3$ 根据抽屉原理就一定有签出现在交点上了。有签在交点上的情况可以直接暴搜出解（每次选交点，删掉覆盖到的矩形，剩下的继续递归选交点）。剩下就是签都在线段上的情况。

首先某块汉堡肉如果相邻三边都是以上那四种线段之一（即包含了一整条边），它必定插签，可以不用考虑；否则离散化（不用真的离散化）矩形边坐标，对每条边可以单独做前后缀连边的 $2-SAT$。

严谨地说，要判无解，但是本题保证有解 qwq

然后这题随机化也能艹过去，好像是什么分 $K$ 类，每类算矩形并，让矩形并最大

[$Code$](https://loj.ac/s/1002813)

### [$JOI2020-建筑装饰4$](https://loj.ac/p/3271)
---

$n^2$ dp 还是很好想的。$dp[i, 0/1, j]$ 表示到 $i$，第 $i$ 位是否为 $A$，选了 $j$ 个 $A$ 的值，只为 $1$ 或 $0$。有一种做法是（猜）结论：$dp[i, 0/1]$ 值为 $1$ 的是一段区间。归纳可证？但是这就没意思了啊 qwq

考虑其他做法。不妨交换状态与值：$dp[i, 0/1, 0/1]$ 表示到 $i$，第 $i$ 位是否为 $A$，$A$/$B$ 的最多个数能是多少。容易记录路径。输出方案时从后往前。

[$Code$](https://loj.ac/s/1001454)

### [$JOI2020-有趣的 Joitter 交友$](https://loj.ac/p/3275)
---

最大值是唬你的，就是能关注则关注。考虑一个关注事件会有什么“副产品”：所有和 $B$ 用户互相关注的 $C$ 都会被 $A$ 关注。这互相关注的关系具有传递性，关注关一团，启发我们把有双向边的点对缩点。发现答案等于 $\sum_S sz(S)(sz(S) - 1) + sz(S)in_deg(S)$

现在要合并两个团，要维护 $sz(sz - 1)$ 和 $sz * in_deg$ 的变化，还要合并 $in$ 和 $out$ 的点对。用启发式合并 + set 存入边出边 + 并查集（合并的时候把信息都拢到根上，并查集帮助找根）可以做到 $O(nlog^2n)$！

还有一个细节，合并可能造成连锁反应，那么对于新的要合并的点对递归处理就好。

[$Code$](https://loj.ac/s/1002124)

### [$JOI2020-遗迹$](https://loj.ac/p/3276)
---

[CCCOrz](https://blog.csdn.net/qq_39972971/article/details/105074251)

[CCCOrz](https://blog.csdn.net/jokerwyt/article/details/105116540)

很妙的题！没有思路，一定先剖析这个操作的原理：怎么找长度为 $2N$ 的序列的结果序列。

发现其中一种方法是从后往前，对于每个 $a[i]$ 如果 $\leq a[i]$ 有空着的位置就选 $i$ 并且填上空位。发现这种方法很利于 $dp$。有个 $simple$ 的想法是 $O(n2^n)$ 的状压，$dp[i, S]$ 表示 $i$ ~ $2N$ 选的位填的集合是 $S$
```
不选：系数为 j - [已填的位置数]
要选：f[i, j] = f[i + 1, j]
     f[i, j + k] = f[i + 1, j] * C([i ~ 2N 要选的位置数] - j, k - 1) * (k + 1) * g[k - 1, k - 1] * fac[k - 1]
     （不与 1 相连的 贡献可以之后算 —— 这步实在太妙了，避免了记录状态）
    其中 g[i, j] 表示 j 个关键位填了 <= i 的数，dp 预处理的时候要满足 [1, i] 内的个数 <= i
```
最后除以 $2^n$，因为我们在一开始就决定为了方便，把两个相同的数也看作有标号的。

这题的某个难点在于“虚实结合”，实际填的数在最后对应的是另一个数

[$Code$](https://loj.ac/s/999539)

### [$JOI2020-星座 3$](https://loj.ac/p/3277)
---

大声喊出来：网 格 图 的 套 路 是 什 么？——笛——卡——尔——树

（大雾

每次从最大的位置 $x$ pia 开，星空被分成三部分：左，$x$ 头顶的，右

$dp[x, i]$ 表示笛卡尔树第 $x$ 个节点最大的位置头上最高的星星高度为 $i$。合并的时候三部分只能有最多一颗星星比最大位置高。用 $pair$（最高星星高度 + $dp$ 值）+ $set$ 可以轻松实现，启发式合并 $O(n log^2 n)$

[$Code$](https://loj.ac/s/1000065)

### [$JOI2020-收获$](https://loj.ac/p/3278)
---

恶心 & 有意思的题。

员工是不定的，而苹果成熟的时间都相同，因为询问的是人，考虑人不动，苹果动，也许会有一些绝妙的发现。从苹果向第一个采摘它的员工 1 连边，再从员工 1 向第二个采摘它的员工 2 连边... 每个员工都有一个出边，形成了基环内向树森林。分别对每棵基环内向树统计答案。把询问离线下来放在节点上。

一个苹果的贡献怎么算？先断环成链，有两种情况：

1. 苹果到该点没有经过断边
2. 经过了断边

第一种情况就动态开点线段树（下标为时间），第二种可以化成下取整柿子然后维护余数。一个子树的贡献可以进去和出去时做差得到。

[$Code$](https://loj.ac/s/1000206)

### [$CF436E$](https://www.luogu.com.cn/problem/CF436E)
---

出到模拟赛里，比赛时就知道肯定是反悔贪心了，但我就是不会。。

反悔贪心先固定一种顺序，一般是个数每次加一，然后每步要么选择，要么反悔。一般用堆来维护决策集合。（为什么用堆就不用说了吧？！）

本题共有四种决策：
* 选择
    1. 选一个新的 $i$, $a_i$
    2. 从选了一个的 $i$ 里再选一个, $b_i - a_i$
* 反悔
    1. 去掉只选了一个的 $i$，再选两个 $j$，$b_j - a_i$
    2. 去掉选了两个的 $i$ 的第二个，再选两个 $j$，$b_j - (b_i - a_i)$
用四个堆分别维护这四种决策。

这题有好多种乱搞做法。
比如 $dst$ 的：
按照 $a_i$ 和 $b_i - a_i$ 的大小关系分类
$a_i \leq b_i - a_i$ 没有依赖关系，可以单独考虑；
但是 $a_i > b_i - a_i$ 的就要捆绑了
最后可能会有剩一个空的情况，那么枚举 + 分讨就好了？

### [$WC2008-游览计划$](https://www.luogu.com.cn/problem/P4294)
---

一眼最小生成树。但是上方格图了？？？

斯坦纳树，一种 奇 形 怪 状 的状压最小生成树算法。

$dp[i, S]$ 表示串起了 $S$ 集合的点，根为 $i$。两种转移：

1. 每次就把一个集合往根上并就好: $dp[i, S | S'] = min{ dp[i, S] + dp[i, S'] - val[i] }$
2. 换根就一步一步往身边的节点换: $dp[i, S] = min{ dp[j, S] + val[i], (i, j) \in E }$

发现第一个转移按秩，第二个转移无明显顺序，干脆套个 $spfa$，就做完了。以 $s$ 为划分阶段。

这是斯坦纳树的常规套路。

### [$THUSCH2017-巧克力$](https://loj.ac/p/2977)

很好的 ~~随 机 化~~ 斯坦纳树题。首先如果 $C$ 很小的话怎么做？我们可以二分中位数（变权值为 $0$/$1$） + 状压跑斯坦纳树。但是我们首要的是选的块数尽量少，次要的是选的 $0$ 尽量多，怎么 $dp$？**这里有个超好的 Trick：把 $0$ 赋为 $inf - 1$，把 $1$ 赋为 $inf + 1$，块数就是 $\lfloor \frac{val + 300}{1000} \rfloor$**

但是 $C$ 大而 $K$ 小。于是想到把 $C$ 种颜色随机分为 $K$ 类跑状压。正确率是 $\frac{k!}{k^k}$，约等于 $0.0384$, 跑个几百次就没问题了。

[$Code$](https://loj.ac/s/991228)

### [$HNOI2013-与或非$](https://www.luogu.com.cn/problem/P3220)
---

（原来与非（$nand$）是真的存在啊，，不是为题而编出来的，，）

这是个很强大的运算，$and$、$or$、$xor$、$not$ 均可用 $nand$ 来表示。$not\ A = A\ nand\ A$, $A\ and\ B = not\ (A\ nand\ B)$, $A\ or\ B = (not\ A)\ nand\ (not\ B)$，而 $xor$ 显然可以由另外三种表出。

所以题目等价于可以将 $n$ 个数任意位运算起来！吼吼

变中找不变。若存在两个位置 $i$ 和 $j$ 使得 $n$ 个数的 $i$ 和 $j$ 位都相同，显然最终搞出的数 $i$ 和 $j$ 位也是相同的。因此数位 $dp$ 的时候从高位到低位考虑，确定当前位后必须将和它相同的位标记一下。

剩余没有互相限制的位置可以任意取 $0$ 或 $1$。为什么？？考虑用线性基的思想构造解（假设当前要取第 $x$ 位为 $1$）：通过一些操作把 $n$ 个数消成上三角；对于第 $x$ 位为 $0$ 的 $a_i$ 把 $a_i$ 取反，否则不动。把 $a$ 全部 & 起来，$x$ 位上必然是 $1$；同时由于 $x$ 没有互相限制的位置，没有其他位上为 $1$。

### [$重返现世$](https://www.luogu.com.cn/problem/P4707)
---

好像第一次做 $k-th\ \min-\max$ 容斥的题。。可能只是板子题，但是 $dp$ 容斥系数的方法挺重要，碰到好几次了记录一下。

$\min_k$ 和 $\max_k$ 可以转化。
$$E(\max_k(S)) = \sum\limits_{T \subset S} (-1)^{|T| - k} C(|T| - 1, k - 1) * E(\min(T))$$
$$E(\min(T)) = \frac{m}{\sum\limits_{t \in T} p_t}$$
容斥这东西的系数显然可以 $dp$，老套路了。

考虑状态怎么设计，我们可以把 $k$ 和 $E(\min(T))$ 给表示到状态里：$f[i, j, k]$ 表示, 当前到第 $i$ 种原料，$\sum p_t = j$, 柿子中的 $k = k$ 时, $\sum\limits_{T \subset S} (-1)^{|T| - k} C(|T| - 1, k - 1)$ 的和。转移：

$f[i, j, k] = f[i - 1, j, k]$ (不选 $i$)

$+ f[i - 1, j - p_i, k - 1] - f[i - 1, j - p_i, k]$（选 $i$）

这是因为 $|T|$ 增加 $1$ 时, $C(|T| - 1, k - 1) = C(|T| - 2, k - 1) + C(|T| - 2, k - 2)$（根据组合数的定义）然后 $-1$ 的指数也改变了，负负得正。

边界：$f[0, 0, k] = 0$,
$f[i, p_i, k] = f[i - 1, p_i, k] + (-1)^{1 - k}C(0, k - 1)$，后面这坨等价于 $[k == 1]$

### [$转盘$](http://loj.ac/p/2495)
---

我们发现如果时间被某个点限制住，就没必要在走到那个点的路上走走停停，直接在出发前一次停个够。

破环成链，在起始点停满时间。枚举起始点，假设从 $st$ 开始，$ans = \min\limits_{st}( \max\limits_i( T_i - dist(i, st) ) ) + n - 1$

暴力计算是 $O(n^2)$ 的，考虑数据结构维护

拆一波 $dist$（去掉环的影响）：
$ans = \min\limits_{ 1 \leq i \leq n }( \max\limits_{ 0 \leq j \le n }(T_{i + j} - j) ) + n - 1$


设 $a_i = T_i - i$，$ans = \min\limits_{ 1 \leq i \leq n }( \max\limits_{ i \leq j \le i + n - 1 }{a_j} + i ) + n - 1$，发现是一个后缀 $\max$ 的 $\min$，$\min$ 直接线段树，
后缀 $\max$ 怎么搞？单调队列 $O(n)$，线段树维护 $a$ 的单调增的队列就好了！

用 [这题](https://www.luogu.com.cn/problem/P4198) 的做法，分治的合并，非常强。

接下来证明我们可以统计窗口大小 $= n$ 的答案。因为 $a_i = T_i - i, a_{i + n} = T_i - i - n$, 所以窗口大小 **$\leq n$**;
又因为窗口大小 $\geq \frac{1}{2}$ 区间长度，对于最大的区间 $[1, 2n]$ 而言 **$\geq n$**。

[$Code$](https://loj.ac/s/985524)

### [$ZJOI2019-线段树$](https://uoj.ac/problem/467)
---

现在看看，一眼期望嘛。。老套路了：用期望做计数题

比较巧妙的是状态设计，除了维护本点为 $1$ 的概率外，还维护祖先为 $1$ 的概率。设其分别为 $f$ 和 $g$。

下面分五种情况：
1. 全覆盖的点: $g_i = \frac{1}{2} g_i + \frac{1}{2}$
2. 本点: $f_i = \frac{1}{2}f_i + \frac{1}{2}$, $g_i = \frac{1}{2}g_i + \frac{1}{2}$
3. 到根经过的路径上点: $f_i = \frac{1}{2}f_i$, $g_i = \frac{1}{2}g_i$
4. 靠近路径但全不覆盖的点: $f_i = \frac{1}{2}f_i + \frac{1}{2}g_i$, $g_i = g_i$
5. 毫无影响的点: $f_i = f_i$, $g_i = g_i$

$2$, $3$ 和 $4$ 都是 $modify$ 的时候会 $psd$ 的，所以直接操作就好。唯独要给 $1$ 打 $tag$：我们让这个 $tag$ 打在系数和常数上，发现若打了 $k$ 个 $\frac{1}{2}$，系数就是 $(\frac{1}{2})^k$, 常数是 $1 - (\frac{1}{2})^k$

[$Code$](https://uoj.ac/submission/438768)

### [$三角形$](https://uoj.ac/problem/418)
---

正着做，每个点受到它所有儿子的限制，无法避免这个限制，没法做。技巧：得失转换题考虑倒一下顺序，**每个点就只受父亲影响了**

每次操作可以用二元组 $((\sum w_{son}) - w_i$, $\sum w_{son})$来表示，分别是最终影响和操作过程中达到的最大值

优先级好算，堆维护，取队首和父亲绑一块，老套路了。绑的时候合并操作，影响相加，最大值更新。这样就算出了全局最优解。

而根据操作序列反推出每个子树答案的方法也很巧妙：考虑每个子树的操作序列是全局的一个子序列，我们用线段树合并求解所有子树的答案就可以了。线段树上以时间为下标。

[$Code$](https://uoj.ac/submission/438673)

### [$UOJ211-逃跑$](https://uoj.ac/problem/211)

求方差就是求每种情况经过位置个数和，以及经过位置个数平方和。个数和可以 $dp$: $f[i, x, y]$ 表示走了 $i$ 步第一次到达 $(x, y)$ 的概率，$g[i, x, y]$ 表示走了 $i$ 步到达 $(x, y)$ 的概率，显然 $f$ 可以由 $f$ 和 $g$ 容斥得到。

平方和老套路，把 $x^2$ 拆成 $C(x, 2) + x$，考虑其实际意义就是到达了两个地点的概率——这怎么搞？$h[i, x, y]$ 表示走了 $i$ 步在到达 $(a, b)$ 前到达过 $(a - x, b - y)$ 的概率和，要减去在到达 $(a - x, b - y)$ 前到达过 $(a, b)$ 的概率和。

[$Code$](https://uoj.ac/submission/440153)

### [$UOJ141-量子态的棋盘$](https://uoj.ac/problem/141)
---

首先那么多球是唬你的：假设有 $a$ 个球流到 $(x, y)$ 上，那么会分为两个支流，分别为 $a / 2$ 和 $(a + 1) / 2$，就看 $(x, y)$ 初始状态决定那个支流到那个方向。$n$、$m$ 那么小，直接 $80$ 进制状压，总状态数只有几十万，$hashmap$ 冲一发就好。

[$Code$](https://uoj.ac/submission/440103)

### [$CF1163E$](https://www.luogu.com.cn/problem/CF1163E)
---


### [$CF1163F$](https://www.luogu.com.cn/problem/CF1163F)
---

读完题我想：如果能维护不经过某条边的最短路就好了。。

正解很硬核，直接最短路树 + 分讨
1. $(u, v)$ 不在最短路上，变小，新值与初始答案取个 $\min$
2. $(u, v)$ 不在最短路上，变大，无影响
3. $(u, v)$ 在最短路上，变小，答案减小对应的值；
4. $(u, v)$ 在最短路上，变大，这个比较麻烦。
回答上面那个问题！线段树！

懂了吗？线段树只要维护原始最短路的断边情况。$[L, R]$ 表示不用区间 $[L, R]$ 的边的最短路

经典套路：**批量**维护删除某个点或边的可以尝试分治

某条边 $(u, v)$ 所在的最短路，对删除_连接 $u$ 的、在 $u$ 之前，在最短路上的最后点_ ~ _连接 $v$ 的、在 $v$ 之后，在最短路上的最前点_之间的边有贡献

