---
title: 十二月学习计划
date: 2020-12-07 07:36:40
tags: 
mathjax: true
---

~~我就是喜欢挖深坑!~~

长文给我的感觉特别安心啦其实是。然后一些题目的题解也要整理整理，学习计划也要安排给自己看。

$1.16$ 前的学习计划就, 刷

- $CodePlus$（选）
- $NOI$（12 ~ 20）
- $JOI$（选）
- 清华集训（14 ~ ?）

多学数学知识:

- 群论
- 生成函数
- 单位根反演
- 斯特林相关

---

## $\mathcal{12.7}$
---

写了 $Polya$ 板题，多项式 $exp$ 板题，然后现在巨想写不板的题（

### [$洛谷4980-Polya 板题$](https://www.luogu.com.cn/problem/P4980)

$Polya$ 定理：
$|X/G| = \frac{1}{|G|} \sum\limits_{g \in G} |M|^{c(g)}$

其中
* $X$ 是不考虑本质不同的染色方案集合
* $G$ 是各种翻转啊旋转啊等操作构成的置换群
* $X/G$ 是本质不同的染色方案集合
* $M$ 是颜色数
* $c(g)$ 是置换 $g$ 的不相交循环置换个数

然后这题我们直接套公式就可以做！
$ans = \frac{1}{n} \sum\limits_{g \in G} n^{c(g)}$

枚举 $c(g)$，设 $g$ 旋转了 $i$，则 $c(g) = gcd(n, i)$，因为某个点在置换 $g$ 的重复作用下经过 $lcm(n, i)$ 次操作回到自身，所以 $c(g) = \frac{n * i}{lcm(n, i)} = gcd(n, i)$

$\phi(n / i)$ 为其系数，为啥？

$\sum\limits_{k = 1}^{n} [gcd(n, k) == i]= \sum\limits_{k = 1}^{n / i} [gcd(n, k * i) == i]$

$= \sum\limits_{k = 1}^{n / i} [gcd(n / i, k) == 1] = \phi(n / i)$

所以有 $ans = \frac{1}{n} \sum\limits_{i | n} \phi(n / i) * n^i$, $O(\sqrt{n})$

### [$洛谷5574-任务分配问题$](https://www.luogu.com.cn/problem/P5574)

为了顺口我们求逆序对最少（翻转一下 $a[i]$ 就好）

$calc(l, r)$ 为 $[l, r]$ 的逆序对个数。看起来像斜率优化但它不能。。我相信一定可以优化！

发现有决策单调性：$calc(l - 1, r + 1) + calc(l, r) \geq calc(l - 1, r) + calc(l, r + 1)$
易证。
于是可以经典决策单调分治 + 树状数组推区间。
$O(Knlog^2n)$

## $\mathcal{12.8}$
---

### [$洛谷4128-有色图$](https://www.luogu.com.cn/problem/P4128)

染色的是边，转的是点。考虑对于某种转点方案，其等价类个数。那边就要分_连接同个循环的点_和_连接不同循环的点_讨论。

同个循环：设长度为 $b_i$，有 $b_i / 2$ 种等价类

不同循环：等价类大小为 $lcm(b_i, b_j)$，等价类个数为 $b_i * b_j / lcm(b_i, b_j) = gcd(b_i, b_j)$

现在知道了具体 $b_i$ 就能算答案了。
考虑 $n$ 的分拆，$n$ 只有 $53$，十分稳（实际上要 $7e7$）（问题不大）

我们枚举 $b$ 的多重集，系数也挺正常的：$\frac{n!}{\prod b_i!} * \prod (b_i - 1)! * \frac{1}{c_i!}$

其中第一项是把点分配到多重集里，第二项是每个集合排顺序（是置换嘛），第三项是除掉大小相同的集合算重的方案。

有双倍经验题：HNOI2009-图的同构计数。第一反应是无标号连通图计数 + 背包——不对劲，我只会有标号的。再一想，边的有无不正对应着此题中染成黑或白色吗？于是看题解，果真就是有色图的卡常版——把 gcd 在中途计算掉就能 AC 此题。

## $\mathcal{12.9}$
---

## $\mathcal{12.10}$
---

### [$ZJOI2019-开关$](https://www.luogu.com.cn/problem/P5326)

单独写博客了

## $\mathcal{12.11}$
---

### [$BZOJ4221-Kangaroo$](https://darkbzoj.tk/problem/4221)

我们发现袋鼠和袋子可拆。不妨分别升序排列，看起来很可以 dp。我们要做到的就是没匹配的 $min(a) \geq max(b)$。

枚举从左往右第一个没有被塞到袋子里的袋鼠 $s$，对于这个 $s$ 找到它能匹配的最小的袋子 $t$。由于 $s$ 是第一个没匹配的袋鼠，$s$ 左边的袋鼠和 $t$ 及其右边的袋子都被匹配了。怎么统计方案数？枚举跨越 $(s, t)$ 的对数，即小于 $s$ 的袋鼠同大于 $t$ 的袋子匹配。除去这些，剩下的匹配对就是小于 $s$ 和小于 $t$，大于 $s$ 和大于 $t$。左右分别 $n^2$ dp。

[$Code$](https://darkbzoj.tk/submission/99567)

## $\mathcal{12.12}$
---

下午的 THUPC2020，享受比赛，好好打吧！

## $\mathcal{12.13}$
---

为了做「如果奇迹有颜色」，学习了半个常系数齐次线性递推。非常颓废，肝了 15 页生物。

## $\mathcal{12.14}$
---

AC 了「如果奇迹有颜色」。题解在「【学习笔记】常系数齐次线性递推」里。现在想去数数。

做了「烷基计数」，题解在「【学习笔记】生成函数」

### [$comet2280-另一道树题$](https://cometoj.com/contest/48/problem/D?problem_id=2280)

计数转期望，期望用整数概率公式拆分。这样就化“恰好”为“至少”了，现在我们要统计走 $i - 1$ 步不会走到一块的方案数。只要并查集把走到一块的并起来，方案数就是 $(\prod (siz + 1)) - n$，最后还要减去 $n$。

### [$PKUWC2018-Slay the Spire$]

这是一道求和题。
假设选了 $i$ 张强化牌和 $m - i$ 张攻击牌
1. $i < K$，$i$ 张强化牌，$K - i$ 张最大的攻击牌
2. $i \geq K$，$K - 1$ 张最大的强化牌，一张最大的攻击牌。

正确性易证。所以只要 $dp$ 就好了？$f[i, j]$ 表示前 $i$ 张强化牌摸了 $j$ 张的倍数和，$g[i, j]$ 表示前 $i$ 张攻击牌摸了 $j$ 张的和。注意 $dp$ 的时候如果攻击牌数 $j \leq m - (K - 1)$，那只能取一张牌，为了方便 $dp$ 我们把攻击牌升序排序，这样取的牌就是当前这张。第一维可以倒序搞掉。

## $\mathcal{12.15}$
---

做了「烷烃计数」，题解在「【学习笔记】生成函数

### [$找树$](https://loj.ac/p/6622)

要理解透。解法是矩阵树的变形应用：众所周知矩阵树只能求生成树个数和生成树边积和。考虑全是异或怎么做，就是加一维 $a[x, y, z]$ 表示矩阵 $[x, y]$ 位置值为 $[z]$ 的个数，那么求行列式的时候乘法变成 $FWT$ 就行了。

但你怎么定义 $FWT$ 的逆元？太 $naive$ 了还是！

先 $FWT$，对于每个 $[z]$ 求出行列式放在答案数组里，再把答案数组 $IFWT$ 回去就好了。复杂度 $O(n^32^w + n^2w2^w)$，$1e9$，在求行列式那里特判一下如果出现 $0$ 就直接返回 $0$，就 $AC$ 了。这是怎么一回事呢，小编也很惊讶。

### [$希望$](https://loj.ac/p/3053)

之前做的，记录一下。

别被高大上的题目唬住了！思路就是算一个救援队的答案，然后 $k$ 次方。点 $x$ 子树里和子树外的要分开算。

$f[x, i]$ 表示子树里深度不超过 $i$ 的连通块方案数，$g[x, i]$ 表示不包括子树里（但包括 $x$）的深度不超过 $i$ 的连通块方案数，两个一乘岂不美哉？

转移方程超好写：
- $f[x, i] = (\prod f[y, i - 1]) + 1$
- $g[x, i] = (g[fa[x], i - 1] \prod f[son[fa[x]], i - 2]) + 1$

$n$ $1e6$, $dp$ 又与深度有关，于是想到长剖优化。本题的思路到此为止，接下来 都 是 细 节

$f$ 可以直接算，但是 $g$ 里面那个 $\prod$ 不好搞。

用回退栈可以维护，做 $f$ 的时候从长到短遍历子树，做 $g$ 的时候从短到长遍历子树。

## $\mathcal{12.16}$
---

渐渐，对于安逸享乐的人它是一条长长的下坡路，通向深渊；对于上进的人它是一条长长的阶梯，通向天堂。

为了不滑进深渊我只有拼尽全力。**我要终止看题解的不良习惯——再这样下去，xml，你会光速退役的。**

comet第六场 E，uoj311，uoj370，uoj316，loj2570, vp 一场 cf（哼，痴人说梦）

### [$LOJ6356-四色灯$](https://loj.ac/p/6356)

$O(nm)$ 是非常好做的啊，算出每个位置被经过的次数 $cnt$，贡献就是 $\sum_k C(cnt, 4k) * 2^{m - cnt}$

考虑 $cnt \in [0, 20]$，我们枚举选了哪些 $x_i$。设该集合为 $s$，那么被 $lcm(x \in S)$ 经过的点应当有贡献。但是对于 $s \subset s'$，$s'$ 经过的点 $s$ 也经过了，所以需要容斥出被 $s$ 经过且不被任何 $s$ 的超集经过的点个数，表示为 $g[s]$。

直接枚举超集 $O(3^m)$，TLE；考虑进一步优化。写出柿子：$\sum_s g[s] \sum_k C(|S|, 4k) * 2^{m - |S|}$，发现 $|S|$ 相同的可以拢到一起。设 $G[i] = \sum\limits_{|S| = i} g[s]$，$G$ 很容易容斥得到，比如 $j > i$，考虑 $G[j]$ 对 $G[i]$ 的容斥贡献，只是把原先分项并到了一起，乘组合数 $C(j, i)$ 就好。

[$Code$](https://loj.ac/s/1013566)

## $\mathcal{12.17}$
---

感觉做事像有阻力一样。这阻力来自哪里？过于注重形式，便颓废了。这阻力也是犹豫不决，是自我怀疑，虽然已经比前几个月的我症状轻多了。双脚往前抵着怎么会走的快、走得轻松呢？

看题解这个事情，本质是急于求成，但只是一时之利，于长远则是退役的加速器。思考的充分一点，一道题做几个小时也是不亏的。**务必从现在开始加强独立思考！！！**

机房的大环境与我是两个世界，带上耳塞，沉浸在自己的探究中。入神时便不受大环境影响了。

做题量要采取策略来保证，一天一套 CF。我是说，在学数学的同时也别忘了 CF，你看 zjy、kqh CF 都切的很多。做好题，不要做网红题，要按照自己的弱点来选题。最近的省选模拟赛，打满时间感觉不现实，但每道题都要思考透。

写题，思考透再开码。

每天坚持着充实着，有付出有收获，一切都会变好的！！！（最近就是效率低下，感到空虚了。

劳谦君子，有终吉。

### [XJOI1626 T3]

n = 50 是 TC 原题。但明显可以优化嘛。发现瓶颈在于容斥时并查集的操作。想到每一位建虚点。连通块数由两部分组成：被选的虚点和与它相连的点们，没被选的点们。大概可以高维前缀和。（高维前缀和这个东西就是 FMT 啦。

### [$XJOI1627 T1$]

经典套路，树上路径问题考虑边分治或者点分治 + 堆。我原来写的边分，也可以吧，但是点分多香啊，不用三度化。

为什么不能对每个重心将子树大小排序算答案？每个重心丢 $K$ 个距离到答案堆里，堆不得炸掉。。复杂度也不对嘛。——那就别急着算出当前最优啊，不如把所有重心全部跑完再算最优。这就是超级钢琴的套路了。

对每个重心，它的子树中点的连边情况是一个区间。丢区间进堆，$st$ 表维护 $\max$。每次取区间，统计答案，裂成两半。

点分治的优点在哪儿呢？点和点的距离可以直接相加得出。$O(nlog^2n + mlogn)$，AC 不了就很难受。

upd：这题重点在超级钢琴啊，前面的有一百种做法，只要保证距离可以直接相加得出就好。简单的 dfs 序上跑也可以额。或者线段树维护直径集合。

### [$XJOI1627 T2$]

[题解](https://www.cnblogs.com/chdy/p/13114664.html)

我想了个 $O(\frac{n^4}{32})$ 的 bitset 假做法，被大捆绑杀了

### [$ZJOI2020-传统艺能$](https://loj.ac/p/3312)

和 19 年的一样讨论啊。。$K$ 如此之大，列出 $dp$ 方程后容易想到矩阵快速幂吧。算是 2.0 版本吧，依旧觉得维护这五个量——访问祖先/自己/子树/兄弟/不交，挺巧妙的。$O(n3^3logK)$

### [$XJOI1627 T3$]

一个循环节 $2$ 的串会被 $4$ 的时候再统计一次，考虑反演出来：$f[i, j]$ 表示以 $i$ 为结尾的串，循环节恰好为 $j$ 的个数，$g[i, j]$ 表示以 $i$ 为节点的串，循环节是 $j$ 的因数的个数。那么显然有 $g[i, j] = \sum\limits_{d | j} f[i, d]$, $f[i, j] = \sum\limits_{d | j} g[i, d] * \mu(\frac{j}{d})$。答案是 $C(n + 1, 2) - \sum{f[i, j]}$，现在考虑怎么算 $g$.

枚举 $d$，把整个串划分为长度为 $d$ 的块，块与块之间的位置我们称为关键点，算出相邻关键点向左的最长公共后缀和向右的最长公共前缀。要相加 $\geq d$ 才行，维护到当前块的最长合法块位置就好了，是 $O(nlogn)$ 的！$hehezhou$ $nb$！！！

还有一种做法就是发现某个答案串必然包含了 $Lyndon\ root$，然后跑 $Runs$。（虽然没听懂但还是要记下来

[$Code$](https://loj.ac/s/1014629)

## $\mathcal{12.18}$
---

To do list: vp cf, 订正昨天模拟赛，17线段树，20抽卡, loj6611，学习 Runs

刚刚去听了职业规划的计算机专场。高薪、创新 大概是一些关键词吧。理科要好。职业的活动性很大（我在说什么啊）可能性很多。主要是做大数据，网络之类的。说实话目前真没什么兴趣。单论兴趣的话最现实的应该是小提琴吧（你追的上人家专业生嘛）还没想好，总之先走着吧，“如果没有坑，就先让自己成为萝卜”。