---
title: 'XJOI200728 题解'
date: 2020-07-28 14:42:40
tags: 
    - 比赛
    - 线段树合并
    - 分块
mathjax: true
---

两道数据结构题给我搞吐了。。。

## A
-----

容易发现矩阵的奇数行（除了1）和偶数行是相同的. 感性理解就是把很多串 1，2，3 ... 穿插在一起，每次转换一下。

可以分块或者莫队做，原题是 CF418E。。。不想写啊qwq

## C
-----

考虑没有操作 2，显然一遍 dfs 就能解决（考虑节点 x，它作为 lca 的贡献可以用 询问的a在子树中的个数 和 子树中黑色点的id和 来算）

考虑有操作 2，本质上多了时间这一维度（经典套路），用线段树合并（时间为下标）

点 x 作为 lca 的贡献就在合并的时候算。显然时间较小的id和对时间较大的询问有影响。因此要计算 左半边的id和 与 右半边的询问个数 之积（线段树上分治处理）

O(nlogn)

``` c++
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; i++)
using namespace std;

const int N = 2e5 + 10;
typedef long long ll;
int n, m, idx;
int col[N], lst[N], rt[N];
ll val[N];
vector<int> nxt[N];
struct node { int cnt, ls, rs; ll sum; }tr[N * 60];

void upd(int x) {
    int ls = tr[x].ls, rs = tr[x].rs;
    tr[x].cnt = tr[ls].cnt + tr[rs].cnt;
    tr[x].sum = tr[ls].sum + tr[rs].sum;
}

void modify(int &x, int l, int r, int pos, int v1, int v2) {
    if (!x) x = ++idx;
    if (l == r) {
        tr[x].cnt += v1;
        tr[x].sum += v2;
        return;
    }
    int mid = (l + r) >> 1;
    if (pos <= mid) modify(tr[x].ls, l, mid, pos, v1, v2);
    else modify(tr[x].rs, mid + 1, r, pos, v1, v2);
    upd(x);
}

void merge(int &x, int y, int l, int r, int id) {
    if (!x || !y) {
        x = (x | y); return;
    }
    if (l == r) {
        tr[x].cnt += tr[y].cnt, tr[x].sum += tr[y].sum; return;
    }
    val[id] += 1ll * tr[tr[x].rs].cnt * tr[tr[y].ls].sum;
    val[id] += 1ll * tr[tr[x].ls].sum * tr[tr[y].rs].cnt;
    int mid = (l + r) >> 1;
    merge(tr[x].ls, tr[y].ls, l, mid, id);
    merge(tr[x].rs, tr[y].rs, mid + 1, r, id);
    upd(x);
}

void dfs(int x, int fa) {
    for (int i = 0; i < nxt[x].size(); i++) {
        int y = nxt[x][i];
        if (y == fa) continue;
        dfs(y, x);
        merge(rt[x], rt[y], 0, m, x);
    }
}

int main() {
    cin >> n >> m;
    rep(i, 1, n) {
        scanf("%d", &col[i]);
        if (col[i]) modify(rt[i], 0, m, 0, 0, i);
    }
    rep(i, 1, n - 1) {
        int x, y; scanf("%d%d", &x, &y);
        nxt[x].push_back(y), nxt[y].push_back(x);
    }
    rep(i, 1, m) {
        int op, x; scanf("%d%d", &op, &x);
        if (op == 1) {
            modify(rt[x], 0, m, i, 1, 0);
            if (col[x]) val[x] += x;
        } else {
            col[x] ^= 1;
            if (col[x]) {
                modify(rt[x], 0, m, i, 0, x);
            } else {
                modify(rt[x], 0, m, i, 0, -x);
            }
        }
    }
    dfs(1, 0);
    rep(i, 1, n) printf("%lld\n", val[i]);
    return 0;
}
```