---
title: '概率与期望习题选讲'
date: 2020-08-11 11:31:40
tags: 
    - 概率与期望
mathjax: true
---

快乐期望 ~

## **套路1. 直接递推**
-----

### [$[NOI2005]-聪聪与可可$](https://www.luogu.com.cn/problem/P4206)

简单题的样子，$f[i, j] = \frac{\sum f[nxt, k]}{deg_j + 1} + 1$，其中 nxt 是 i 两步能到达的，k 是 j 一步能到达的。**猫和鼠的距离不断减少**，所以状态不会形成环，记忆化搜索就好了。

## **套路2. 无限循环转递推**
-----

（这部分好神仙的！要巧妙设计状态，或者错位相减法（等比数列求和必备技能）等方法化柿子 qvq）

### [$[SHOI2002]-百事世界杯之旅$](https://www.luogu.com.cn/problem/P1291)

应用极限的思想 [题解](https://www.luogu.com.cn/blog/ButterflyDew/solution-p1291)

### [$[六省联考2017]-分手是祝愿$](https://www.luogu.com.cn/problem/P3750)

看起来很神的期望题

首先 50 分从后往前取，好拿吧

考虑正解！从后往前取会确定一些**必须要取**的键，那么就相当于除开这些键 按了其他的键 **就得按同一个键按回来**，相当于多了一个必须要按的键（所以 f 的预处理得从 n，不能从 cnt 开始！）。所以 dp 的状态就是 f[i] 表示从 i 个必选的键转移到 i - 1 个必选的键的期望操作次数

$$f[i] = \frac{i}{n} + \frac{n - i}{n}(1 + f[i] + f[i + 1])$$

第一项表示选了一个必选的，一次就到 i - 1 去了；

第二项表示选了一个其他的，就得 f[i + 1] 次按回来，再 f[i] 次按到 i - 1 去。

``` c++
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; i++)
#define int long long
using namespace std;

const int mod = 100003, N = 1e5 + 10;
typedef long long ll;
ll n, K, cnt, res;
ll col[N], f[N];

ll quick_pow(ll a, ll b) {
    ll ret = 1;
    for (; b; b >>= 1) {
        if (b & 1) ret = ret * a % mod;
        a = a * a % mod;
    } return ret;
}

signed main() {
    cin >> n >> K;
    rep(i, 1, n) scanf("%d", &col[i]);
    for (int i = n; i; --i) {
        if (col[i]) {
            ++cnt;
            for (int j = 1; j * j <= i; j++) {
                if (i % j == 0) {
                    col[j] ^= 1;
                    if (j * j != i) col[i / j] ^= 1;
                }
            }
        }
    }
    for (int i = n; i; --i)  // !!! 从 n 开始
        f[i] = (f[i + 1] * (ll)(n - i) % mod + n) % mod * quick_pow(i, mod - 2) % mod;
    if (cnt <= K) res = cnt;
    else {
        res = K;
        for (int i = cnt; i > K; --i) res = (res + f[i]) % mod;
    }
    rep(i, 1, n) res = res * (ll)i % mod;
    printf("%lld\n", res);
    return 0;
}
```

### [$[UVA10529]-Dumb Bones$](https://www.luogu.com.cn/problem/UVA10529)

太神仙了吧woc

考虑**单独**一张骨牌摆放成功的期望次数 E

玄学化柿子（感性理解）
$$E = 1 + pl(1 + pl(...) + pr(...)) + pr(1 + pl(...) + pr(...))$$
$$= 1 + (pl + pr)(1 + (pl + pr)(...))$$
$$= 1 + (pl + pr) + (pl + pr)^2 + (pl + pr)^3 ... + (pl + pr)^{\infty}$$
$$= \frac{1}{1 - pl - pr}$$
（别化晕了

考虑连续的 x 张骨牌成功的期望。**注意采取最优策略**

放第 x 张骨牌时，如果向左/右，就要花费一些步数去扶起左/右边的骨牌。后面那坨东西，根据**期望的线性性质**

$$f[x] = \min\limits_{i = 1}^x\{f[i - 1] \times \frac{1 - pr}{1 - pl - pr} + f[x - i] \times \frac{1 - pl}{1 - pl - pr} + \frac{1}{1 - pl - pr}\}$$

以往左倒为例解释一下：左边要重搭 $f[i - 1] \times [往左倒的期望次数] = f[i - 1] \times (E - 1) \times \frac{pl}{pl + pr}$，注意这是重搭的，初始还有一次，所以是 $f[i - 1] \times \frac{1 - pr}{1 - pl - pr}$

就做完了。uva 数据只有一组，非常的水，我怕了，题解柿子都不一样。

感想就是，**期望的线性性质真的太重要了！** 不然这种互相影响的问题就没法做了。

### [$[CF908D]-New Year and Arbitrary Arrangement$](https://www.luogu.com.cn/problem/CF908D)

这题的关键在处理边界啦。

容易发现我们需要记录的是当前 a 和 ab 的数量。设 f[i, j] 表示 i 个 a，j 个 ab，那么 $f[i, j] = \frac{pa}{pa + pb}f[i + 1, j] + \frac{pb}{pa + pb}f[i, i + j]$

开头无限多个 b 怎么办？忽略掉，因为对 ab 的数量没有影响。

结尾无限多个 a 怎么办？这个就要搞一搞了。如果 i + j >= k，那么只要加一个 b 就能结束。设 $P_a = \frac{pa}{pa + pb}$, $P_b = \frac{pb}{pa + pb}$

$$f[i, j] = P_b \sum\limits_{k = 0}^{\infty} P_a^k (i + j + k)$$

$$= P_b\sum\limits_{k = 0}^{\infty} P_a^k \times k + P_b(i + j)\sum\limits_{k = 0}^{\infty}P_a^k$$

$$= i + j + \frac{P_a}{P_b}$$

### [$「PKUWC2018」猎人杀$](https://loj.ac/problem/2541)

很妙的概率题。

分母是变化的，很不好求。

问题可以转化一波，变成：死掉的猎人依旧算在概率里面，每一轮一直开枪直到射死一个没死过的猎人。这样每次能选的就是全集了。

设 $W = \sum w_i$, $T = \{w_i(i\ has\ died)\}$, $sum(T) = \sum\limits_{i\ has\ died} w_i$

转化前射死 $i$ 的概率 $P = \frac{wi}{(W - T)}$

转化后射死 $i$ 的概率 $P = \frac{T}{W}P + \frac{wi}{W} = \frac{wi}{W - T}$

两者相等。

。

。

然后考虑容斥，钦定一个不包含 1 的猎人集合 T 在 1 之后死去。除了集合 T 和猎人 1 以外的剩余的猎人不用考虑，因为他们可以任意摆放在 1 的前面后面（也就是说概率是 1）

列出柿子

$$ans = \sum\limits_T (-1)^{|T|} \frac{w_1}{W}\sum\limits_{i = 0}^{\infty} (1 - \frac{sum(T) + w_1}{W})^i$$

等比数列求和

$$ans = \sum\limits_{T} (-1)^{|T|} \frac{w_1}{sum(T) + w_1}$$

枚举 $T$ 再背包预处理容斥系数可以做到 $n^2$，50 pts：

$$ans = \sum\limits_{num = 0}^{W} \frac{w_1}{num + w_1} (\sum\limits_T (-1)^{|T|} [sum(T) == num])$$

100 pts 的话就是后面那坨容斥系数用分治的 NTT 卷一下了（下标是 T），注意不是 cdq 分治，就是普通的分治！就是没有顺序的分治！

好妙【吐血而亡

