---
title: 'NOI2020网络同步赛体验记'
date: 2020-08-18 18:49:40
tags:
    - 比赛
---

## Day1
---

勤勤恳恳的扣了 114 分，取模错误 wa + 字母打错，fst 成 82 分。。。好难受啊

整整 32 分啊。这如果是联赛，谁担的起呢。

## Day2
---

勤勤恳恳的抠了 ？分（对我自己都不确定正确性），民间数据还没出（出了也不测 qvq）

## 出成绩了
-----

108

-----

【此处应有题解】

-----

来补了。

## $D1T1. 美食家$

我想到矩阵快速幂了！写出 5n 个点的转移柿子了！甚至想到预处理 $2^i$ 的矩阵、行向量去乘是 $n^2$ 的了！

但我没写出来。。。好吧，不会就是不会，复杂度是 $O((5n)^3\ log\ T + (5n)^2\ log\ T \times K)$。你别看他有 4e8，人家是 O(能过) 耶= =

upd：考场代码分段乘的时候额外贡献加错位置了= = 我哭

``` c++
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; i++)
using namespace std;

typedef long long ll;
const int N = 55, M = 255;
int n, m, T, K;
int c[N];
struct mat {
    ll x[M][M], n, m;
} f, g[32];
struct festi {
    int t, x, y;
} fes[M];

int ord(int x, int y) { return (x - 1) * 5 + y; }

bool cmp_fes(festi a, festi b) { return a.t < b.t; }

mat operator * (mat a, mat b) {
    mat c;
    memset(c.x, ~0x3f, sizeof(c.x));
    c.n = a.n, c.m = b.m;
    rep(i, 1, a.n)
        rep(j, 1, b.m)
            rep(k, 1, a.m)
                c.x[i][j] = max(c.x[i][j], a.x[i][k] + b.x[k][j]);
    return c;
}

int main() {
    cin >> n >> m >> T >> K;
    rep(i, 1, n) scanf("%d", &c[i]);

    memset(f.x, ~0x3f, sizeof(f.x));
    memset(g[0].x, ~0x3f, sizeof(g[0].x));
    f.x[1][1] = c[1];
    f.n = 1, f.m = g[0].n = g[0].m = 5 * n;
    rep(i, 1, n)
        rep(j, 1, 4)
            g[0].x[ord(i, j)][ord(i, j + 1)] = 0;

    rep(i, 1, m) {
        int x, y, z; scanf("%d%d%d", &x, &y, &z);
        g[0].x[ord(x, z)][ord(y, 1)] = c[y];
    }
    rep(i, 1, 30) g[i] = g[i - 1] * g[i - 1];

    rep(i, 1, K)
        scanf("%d%d%d", &fes[i].t, &fes[i].x, &fes[i].y);
    sort(fes + 1, fes + K + 1, cmp_fes);
    fes[0].t = 0;
    fes[K + 1].t = T;
    rep(i, 1, K + 1) {
        int tim = fes[i].t - fes[i - 1].t;
        rep(j, 0, 30) if ((tim >> j) & 1) f = f * g[j];
        if (i <= K) {
            f.x[1][ord(fes[i].x, 1)] += fes[i].y;
        }
    }
    printf("%lld\n", max(-1ll, f.x[1][1]));
    return 0;
}
```

## $D1T2. 命运$

这个真是连 dp 方程都想不到。。。比赛时就写了最暴力的指数级容斥。。

$dp[i, j]$ 表示 $i$ 的子树内状态已经确定，没有满足的链顶点的最大深度为 $j$ 的方案数（记录最深是因为深的满足了，浅的也满足了），边界就是链都满足了，$j = 0$

$$dp[x, i] = (\sum\limits_{j = 0}^{dep_x} dp[x, i] \times dp[y, j]) + (\sum\limits_{j = 0}^i dp[x, i] \times dp[y, j]) + (\sum\limits_{j = 0}^{i - 1} dp[x, j] \times dp[y, i])$$

前两部分分别是 $(x, y)$ 这条边为 1 和为 0 的方案数
二维dp，前缀和形式。。噫，这个东西和 pkuwc2018-minimax 好像啊！
没错，就是整体dp，上线段树合并。

跟 minimax 一样的，碰到叶子结点就返回，其他节点由儿子节点 upd 上来。

``` c++
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; i++)
using namespace std;

const int mod = 998244353, N = 5e5 + 10, M = N * 60;
int n, m, idx;
int dep[N], mxd[N];
int to[N << 1], nxt[N << 1], lnk[N], cnt;
int ls[M], rs[M], sum[M], mul[M], T[M];

void add(int x, int y) {
    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;
}

void upd(int x) {
    sum[x] = (sum[ls[x]] + sum[rs[x]]) % mod;
}

void psd(int x) {
    if (mul[x] != 1) {  // !!! 不是 > 1 !!! 因为这个调了一天半。。。
        if (ls[x])
            mul[ls[x]] = 1ll * mul[ls[x]] * mul[x] % mod,
            sum[ls[x]] = 1ll * sum[ls[x]] * mul[x] % mod;
        if (rs[x])
            mul[rs[x]] = 1ll * mul[rs[x]] * mul[x] % mod,
            sum[rs[x]] = 1ll * sum[rs[x]] * mul[x] % mod;
        mul[x] = 1;
    }
}

int merge(int x, int y, int l, int r, int s1, int s2) {
    if (!x && !y) return 0;
    if (x && !y) {  // 遇见叶子节点返回
        sum[x] = 1ll * sum[x] * s1 % mod;
        mul[x] = 1ll * mul[x] * s1 % mod;
        return x;
    }
    if (!x && y) {  // 遇见叶子节点返回
        sum[y] = 1ll * sum[y] * s2 % mod;
        mul[y] = 1ll * mul[y] * s2 % mod;
        return y;
    }
    if (l == r) {  // 遇见叶子节点返回
        sum[x] = (1ll * sum[x] * (s1 + sum[y]) % mod + 1ll * sum[y] * s2 % mod) % mod;
        return x;
    }
    psd(x), psd(y);
    int mid = (l + r) >> 1;
    int t1 = sum[ls[y]], t2 = sum[ls[x]];
    ls[x] = merge(ls[x], ls[y], l, mid, s1, s2);
    rs[x] = merge(rs[x], rs[y], mid + 1, r, (s1 + t1) % mod, (s2 + t2) % mod);
    upd(x);
    return x;
}

int query(int x, int l, int r, int lx, int rx) {
    psd(x);
    if (lx <= l && r <= rx) return sum[x];
    int mid = (l + r) >> 1, ret = 0;
    if (lx <= mid) ret = query(ls[x], l, mid, lx, rx);
    if (rx > mid) ret = (ret + query(rs[x], mid + 1, r, lx, rx)) % mod;
    return ret;
}

void insert(int &x, int l, int r, int pos) {
    x = ++idx, mul[x] = 1;
    if (l == r) { sum[x] = 1; return; }
    int mid = (l + r) >> 1;
    if (pos <= mid) insert(ls[x], l, mid, pos);
    else insert(rs[x], mid + 1, r, pos);
    upd(x);
}

void calcd(int x, int fa) {
    dep[x] = dep[fa] + 1;
    for (int i = lnk[x]; i; i = nxt[i]) {
        int y = to[i];
        if (y == fa) continue;
        calcd(y, x);
    }
}

void dfs(int x, int fa) {
    insert(T[x], 0, n, mxd[x]);
    for (int i = lnk[x]; i; i = nxt[i]) {
        int y = to[i];
        if (y == fa) continue;
        dfs(y, x);
        int t1 = query(T[y], 0, n, 0, dep[x]), t2 = 0;
        T[x] = merge(T[x], T[y], 0, n, t1, t2);
    }
}

int main() {
    cin >> n;
    rep(i, 1, n - 1) {
        int x, y; scanf("%d%d", &x, &y);
        add(x, y), add(y, x);
    }
    cin >> m;
    calcd(1, 0);
    rep(i, 1, m) {
        int x, y; scanf("%d%d", &x, &y);
        mxd[y] = max(mxd[y], dep[x]);
    }
    dfs(1, 0);
    printf("%d\n", query(T[1], 0, n, 0, 0));
    return 0;
}
```

## $D1T3. 时代的眼泪$

## $D2T1. 制作菜品$

## $D2T2. 超现实树$

## $D2T3. 翻修道路$