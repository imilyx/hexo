---
title: 'NOI2020网络同步赛体验记'
date: 2020-08-18 18:49:40
tags:
    - 比赛
mathjax: true
---

## Day1
---

勤勤恳恳的扣了 114 分，取模错误 wa + 字母打错，fst 成 82 分。。。好难受啊

整整 32 分啊。这如果是联赛，谁担的起呢。

## Day2
---

勤勤恳恳的抠了 ？分（对我自己都不确定正确性），民间数据还没出（出了也不测 qvq）

## 出成绩了
-----

108

-----

【此处应有题解】

-----

来补了。

## $D1T1. 美食家$

我想到矩阵快速幂了！写出 5n 个点的转移柿子了！甚至想到预处理 $2^i$ 的矩阵、行向量去乘是 $n^2$ 的了！

但我没写出来。。。好吧，不会就是不会，复杂度是 $O((5n)^3\ log\ T + (5n)^2\ log\ T \times K)$。你别看他有 4e8，人家是 O(能过) 耶= =

upd：考场代码分段乘的时候额外贡献加错位置了= = 我哭

``` c++
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; i++)
using namespace std;

typedef long long ll;
const int N = 55, M = 255;
int n, m, T, K;
int c[N];
struct mat {
    ll x[M][M], n, m;
} f, g[32];
struct festi {
    int t, x, y;
} fes[M];

int ord(int x, int y) { return (x - 1) * 5 + y; }

bool cmp_fes(festi a, festi b) { return a.t < b.t; }

mat operator * (mat a, mat b) {
    mat c;
    memset(c.x, ~0x3f, sizeof(c.x));
    c.n = a.n, c.m = b.m;
    rep(i, 1, a.n)
        rep(j, 1, b.m)
            rep(k, 1, a.m)
                c.x[i][j] = max(c.x[i][j], a.x[i][k] + b.x[k][j]);
    return c;
}

int main() {
    cin >> n >> m >> T >> K;
    rep(i, 1, n) scanf("%d", &c[i]);

    memset(f.x, ~0x3f, sizeof(f.x));
    memset(g[0].x, ~0x3f, sizeof(g[0].x));
    f.x[1][1] = c[1];
    f.n = 1, f.m = g[0].n = g[0].m = 5 * n;
    rep(i, 1, n)
        rep(j, 1, 4)
            g[0].x[ord(i, j)][ord(i, j + 1)] = 0;

    rep(i, 1, m) {
        int x, y, z; scanf("%d%d%d", &x, &y, &z);
        g[0].x[ord(x, z)][ord(y, 1)] = c[y];
    }
    rep(i, 1, 30) g[i] = g[i - 1] * g[i - 1];

    rep(i, 1, K)
        scanf("%d%d%d", &fes[i].t, &fes[i].x, &fes[i].y);
    sort(fes + 1, fes + K + 1, cmp_fes);
    fes[0].t = 0;
    fes[K + 1].t = T;
    rep(i, 1, K + 1) {
        int tim = fes[i].t - fes[i - 1].t;
        rep(j, 0, 30) if ((tim >> j) & 1) f = f * g[j];
        if (i <= K) {
            f.x[1][ord(fes[i].x, 1)] += fes[i].y;
        }
    }
    printf("%lld\n", max(-1ll, f.x[1][1]));
    return 0;
}
```

## $D1T2. 命运$

这个真是连 dp 方程都想不到。。。比赛时就写了最暴力的指数级容斥。。

$dp[i, j]$ 表示 $i$ 的子树内状态已经确定，没有满足的链顶点的最大深度为 $j$ 的方案数（记录最深是因为深的满足了，浅的也满足了），边界就是链都满足了，$j = 0$

$$dp[x, i] = (\sum\limits_{j = 0}^{dep_x} dp[x, i] \times dp[y, j]) + (\sum\limits_{j = 0}^i dp[x, i] \times dp[y, j]) + (\sum\limits_{j = 0}^{i - 1} dp[x, j] \times dp[y, i])$$

前两部分分别是 $(x, y)$ 这条边为 1 和为 0 的方案数
二维dp，前缀和形式。。噫，这个东西和 pkuwc2018-minimax 好像啊！
没错，就是整体dp，上线段树合并。

跟 minimax 一样的，碰到叶子结点就返回，其他节点由儿子节点 upd 上来。

``` c++
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; i++)
using namespace std;

const int mod = 998244353, N = 5e5 + 10, M = N * 60;
int n, m, idx;
int dep[N], mxd[N];
int to[N << 1], nxt[N << 1], lnk[N], cnt;
int ls[M], rs[M], sum[M], mul[M], T[M];

void add(int x, int y) {
    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;
}

void upd(int x) {
    sum[x] = (sum[ls[x]] + sum[rs[x]]) % mod;
}

void psd(int x) {
    if (mul[x] != 1) {  // !!! 不是 > 1 !!! 因为这个调了一天半。。。
        if (ls[x])
            mul[ls[x]] = 1ll * mul[ls[x]] * mul[x] % mod,
            sum[ls[x]] = 1ll * sum[ls[x]] * mul[x] % mod;
        if (rs[x])
            mul[rs[x]] = 1ll * mul[rs[x]] * mul[x] % mod,
            sum[rs[x]] = 1ll * sum[rs[x]] * mul[x] % mod;
        mul[x] = 1;
    }
}

int merge(int x, int y, int l, int r, int s1, int s2) {
    if (!x && !y) return 0;
    if (x && !y) {  // 遇见叶子节点返回
        sum[x] = 1ll * sum[x] * s1 % mod;
        mul[x] = 1ll * mul[x] * s1 % mod;
        return x;
    }
    if (!x && y) {  // 遇见叶子节点返回
        sum[y] = 1ll * sum[y] * s2 % mod;
        mul[y] = 1ll * mul[y] * s2 % mod;
        return y;
    }
    if (l == r) {  // 遇见叶子节点返回
        sum[x] = (1ll * sum[x] * (s1 + sum[y]) % mod + 1ll * sum[y] * s2 % mod) % mod;
        return x;
    }
    psd(x), psd(y);
    int mid = (l + r) >> 1;
    int t1 = sum[ls[y]], t2 = sum[ls[x]];
    ls[x] = merge(ls[x], ls[y], l, mid, s1, s2);
    rs[x] = merge(rs[x], rs[y], mid + 1, r, (s1 + t1) % mod, (s2 + t2) % mod);
    upd(x);
    return x;
}

int query(int x, int l, int r, int lx, int rx) {
    psd(x);
    if (lx <= l && r <= rx) return sum[x];
    int mid = (l + r) >> 1, ret = 0;
    if (lx <= mid) ret = query(ls[x], l, mid, lx, rx);
    if (rx > mid) ret = (ret + query(rs[x], mid + 1, r, lx, rx)) % mod;
    return ret;
}

void insert(int &x, int l, int r, int pos) {
    x = ++idx, mul[x] = 1;
    if (l == r) { sum[x] = 1; return; }
    int mid = (l + r) >> 1;
    if (pos <= mid) insert(ls[x], l, mid, pos);
    else insert(rs[x], mid + 1, r, pos);
    upd(x);
}

void calcd(int x, int fa) {
    dep[x] = dep[fa] + 1;
    for (int i = lnk[x]; i; i = nxt[i]) {
        int y = to[i];
        if (y == fa) continue;
        calcd(y, x);
    }
}

void dfs(int x, int fa) {
    insert(T[x], 0, n, mxd[x]);
    for (int i = lnk[x]; i; i = nxt[i]) {
        int y = to[i];
        if (y == fa) continue;
        dfs(y, x);
        int t1 = query(T[y], 0, n, 0, dep[x]), t2 = 0;
        T[x] = merge(T[x], T[y], 0, n, t1, t2);
    }
}

int main() {
    cin >> n;
    rep(i, 1, n - 1) {
        int x, y; scanf("%d%d", &x, &y);
        add(x, y), add(y, x);
    }
    cin >> m;
    calcd(1, 0);
    rep(i, 1, m) {
        int x, y; scanf("%d%d", &x, &y);
        mxd[y] = max(mxd[y], dep[x]);
    }
    dfs(1, 0);
    printf("%d\n", query(T[1], 0, n, 0, 0));
    return 0;
}
```

## $D1T3. 时代的眼泪$

咕咕

## $D2T1. 制作菜品$

先将 $d$ 排序。

发现大数据范围里有 $n - 2 \leq m$，部分分 $m = n - 1$ 似乎很有未来。

考虑部分分 $m = n - 1$，$d_1$ 一定是 $< k$ 的，为什么呢？如果 $d_1 \geq k$, 那么 $\sum d_i \geq n times k > (n - 1) times k = m \times k = \sum d_i$，矛盾。每次削掉第一项，$n$ 转化成 $n - 1$，一定能够构造出来。

考虑 $m \geq n$ 时，$d_n \geq k$，证明方法同上面类似。于是将 $d_n -= k$，**就转化成了 $m = n - 1$ 的问题**

最后一步！$m = n - 2$ 怎么搞。。可以证明，$m = n - 2$ 有解的充要条件是可以划分为两个 $m = n - 1$ 的子问题。充分性很好证，必要性就比较妙：考虑一个 n 个点的图，菜品视为边，那么最多只有 n - 2 条边，不会连通，此时必然存在至少两个连通块是树的形态——为什么？如果是环，边就不够用了。

实现的话，设 $S$ 是分出来的集合之一，$sz = |S|$, 那么 $\sum\limits_{i \in S} d_i = (sz - 1) \times k$，$\sum\limits_{i \in S} (d_i - k) = -k$，这是个 dp，f[i, j] 表示前 i 个任意取能否使得总和为 j，bitset 维护, $O(\frac{n \times (n \times k)}{w})$

``` c++
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; i++)
using namespace std;

typedef pair<int, int> pii;
const int N = 505, M = 5e3 + 5;
int T, n, m, K, d[N], vis[N];
bitset<N * 10000> f[N];
set<pii>::iterator it;
set<pii> s;  // 传参比较慢，会 T，所以 set 开全局

void solve(int m) {
    if (!m) return;
    int n = s.size();
    if (n <= m) {
        it = s.end(); --it;
        pii t = *it;
        s.erase(it);
        printf("%d %d\n", t.second, K);
        t.first -= K;
        if (t.first) s.insert(t);  // !!! 不然会 T
    } else {
        it = s.begin();
        pii u = *it; s.erase(it);
        it = s.end(); --it;
        pii v = *it; s.erase(it);
        printf("%d %d %d %d\n", u.second, u.first, v.second, K - u.first);
        v.first -= K - u.first;
        if (v.first) s.insert(v);
    }
    solve(m - 1);
}

void solve1() {
    s.clear();
    rep(i, 1, n) s.insert(make_pair(d[i], i));
    solve(m);
}

void solve2() {
    rep(i, 1, n) d[i] -= K;
    f[0].reset();
    f[0][n * K] = 1;
    rep(i, 1, n) {
        if (!d[i]) f[i] = f[i - 1];
        else if (d[i] > 0) f[i] = (f[i - 1] | (f[i - 1] << d[i]));
        else f[i] = (f[i - 1] | (f[i - 1] >> (-d[i])));
    }
    if (!f[n][(n - 1) * K]) return puts("-1"), void(0);
    s.clear();
    int cur = (n - 1) * K;
    for (int i = n; i; --i)
        if (f[i - 1][cur - d[i]]) vis[i] = 1, s.insert(make_pair(d[i] + K, i)), cur -= d[i];
    solve((int)s.size() - 1);
    s.clear();
    rep(i, 1, n) if (!vis[i]) s.insert(make_pair(d[i] + K, i));
    solve((int)s.size() - 1);
}

int main() {
    cin >> T;
    while (T--) {
        scanf("%d%d%d", &n, &m, &K);
        rep(i, 1, n) scanf("%d", &d[i]), vis[i] = 0;
        if (m > n - 2) solve1();
        else solve2();
    }
    return 0;
}
```

## $D2T2. 超现实树$

这题好 AT 的样子，结果是道结论题（脑子不好 死也想不出啊。。

[大佬思路](https://www.luogu.com.cn/blog/startd/solution-p6776)

“几乎完备”这种关系可以传递。太妙了吧！！！！！！！！！

``` c++
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; i++)
using namespace std;

typedef pair<int, int> pii;
const int N = 2e6 + 10;
int T, m, n, idx;
vector<pii> tr[N], cur[N];

int lson(int x, int y) {
    return tr[y][x].first;
}

int rson(int x, int y) {
    return tr[y][x].second;
}

bool is_leaf(int x, int y) {
    return !lson(x, y) && !rson(x, y);
}

bool dfs(int u) {
    if (!cur[u].size()) return 0;
    for (int i = 0; i < cur[u].size(); i++) {
        int x = cur[u][i].first, y = cur[u][i].second;
        if (is_leaf(x, y)) return 1;
    }
    int lls, rrs, rls, lrs;
    lls = ++idx, rrs = ++idx, rls = ++idx, lrs = ++idx;
    cur[lls].clear(), cur[rrs].clear(), cur[rls].clear(), cur[lrs].clear();
    for (int i = 0; i < cur[u].size(); i++) {
        int x = cur[u][i].first, y = cur[u][i].second;
        if (lson(x, y) && !rson(x, y)) cur[lls].push_back(make_pair(lson(x, y), y));
        else if (!lson(x, y) && rson(x, y)) cur[rrs].push_back(make_pair(rson(x, y), y));
        else {
            if (is_leaf(rson(x, y), y)) cur[rls].push_back(make_pair(lson(x, y), y));
            if (is_leaf(lson(x, y), y)) cur[lrs].push_back(make_pair(rson(x, y), y));
        }
    }
    if (dfs(lls) && dfs(rrs) && dfs(rls) && dfs(lrs)) return 1;
    return 0;
}

int main() {
    cin >> T;
    while (T--) {
        cin >> m;
        rep(i, 1, m) {
            tr[i].clear();
            tr[i].push_back(make_pair(0, 0));
            cin >> n;
            rep(j, 1, n) {
                int x, y; scanf("%d%d", &x, &y);
                tr[i].push_back(make_pair(x, y));
            }
        }
        idx = 0;
        ++idx;
        cur[idx].clear();
        rep(i, 1, m) cur[idx].push_back(make_pair(1, i));
        if (dfs(idx)) puts("Almost Complete");
        else puts("No");
    }
    return 0;
}
```

## $D2T3. 翻修道路$

咕咕