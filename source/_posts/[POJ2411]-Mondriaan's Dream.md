---
title: "[POJ2411]-Mondriaan's Dream"
date: 2018-08-09 11:41:40
tags:
    - 状压动规
hidden: true
---

https://vjudge.net/problem/POJ-2411

题意：求把 $N * M$ ($1 \leq N, M \leq 11$) 的棋盘分割成若干个 $1 * 2$ 的长方形，有多少种方案。例如当 $N = 2$, $M = 4$ 时，共有 5 种方案。
 
对于任意一种方案，考虑以某一行为界，把整个棋盘横着分成两半。

这时可能有竖着的长方形被切成了两半，那么下一行对应的位置就必须是长方形的下半部分。而其余部分对棋盘的下半部分分割无影响，既可以安排一个横着的 $1 * 2$ 的长方形，也可以让它作为一个竖着的 $1 * 2$ 长方形的一半。

综上所述，我们要使用状压的话，就要把行号作为DP的阶段，把上半部分不断向下扩展。为了描述一行的具体情况，我们用一个 M 位二进制数，其中第 k 位为 1 表示第 k 列是一个竖着的 $1 * 2$ 长方形的上面一半，第 k 位为 0 表示其他情况。

设 $F[i, j]$ 表示第 i 行的状态为 j 时，前 i 行分割方案的总数。j 是用十进制整数记录的 M 位二进制数。

第 i - 1 行的状态 k 能转移到 j，当且仅当：

* j 和 k 执行按位与运算的结果是 0（这保证了每个数字 1 的下方必须是数字 0，代表继续补全竖着的 $1 * 2$ 长方形）。

* j 和 k 执行按位或运算的结果的二进制表示中，每一段连续的 0 都必须有偶数个（这些 0 代表若干横着的 $1 * 2$ 长方形，奇数个 0 则无法分割成这种状态）。

我们可以在DP前预处理 $[0, 2^M - 1]$ 内所有满足 “二进制表示下每一段连续的 0 都有偶数个” 的整数，记录在集合 S 中：

$$F[i, j] = \sum\limits_{j \& k = 0\ and\ j | k \in S} F[i - 1, k]$$

初值：F[0, 0] = 1, 其余均为 0。
目标：F[N, 0]。
时间复杂度：$O(2^M2^MN) = O(4^MN)$。

code:
``` c++
#include <cstdio>
using namespace std;

typedef long long ll;
int n, m;
ll f[15][1 << 11];
bool in_S[1 << 11];

int main() {
    while (~scanf("%d%d", &n, &m) && n && m) {
        for (int i = 0; i < (1 << m); i++) {
            bool cnt = 0, has_odd = 0;
            for (int j = 0; j < m; j++)
                if (i & (1 << j)) has_odd |= cnt, cnt = 0;
                else cnt ^= 1;
            in_S[i] = has_odd | cnt ? 0 : 1;
        }
        f[0][0] = 1;
        for (int i = 1; i <= n; i++)
            for (int j = 0; j < (1 << m); j++) {
                f[i][j] = 0;
                for (int k = 0; k < (1 << m); k++)
                    if ((j & k) == 0 && in_S[j | k])
                        f[i][j] += f[i - 1][k];
            }
        printf("%lld\n", f[n][0]);
    }
    return 0;
}
```