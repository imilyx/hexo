---
title: '[LOJ6289]-花朵'
date: 2020-08-19 20:14:40
tags: 
    - 树链剖分
    - FFT
mathjax: true
---

[传送门](https://loj.ac/problem/6289)

看它 $id$ 跟我 $loj$ $id$ 相同就做了做 => 调了 $3h+$ => 不调了md 180行ಥ_ಥ 全给我wa掉我🐰了 

本题的 dp 方程很好想：$f[x, 0/1, i]$ 表示 $x$ 子树里选了 $i$ 个，$x$ 不选/选的快乐程度和。这样大概是 $O(n^3)$ 的。

发现合并的时候是背包，想到卷积优化，$O(n^2 logn)$。

还能优化！轻重链剖分，先做轻儿子子树，再把重链上节点的轻儿子合并到 $fa$ 那里，再对于每条重链把答案合并到链顶节点处，$O(nlog^3n)$。注意合并答案的时候分治做，这样是两只 $log$ 的（一个个卷太慢啦！）

复杂度分析大概就是，有不超过 $log$ 条重链和 $log$ 条轻链，每个重链顶做一次两只 $log$ 的轻儿子合并 + 常数有点小大的两只 $log$ 的链信息合并。

错误的代码贴一份吧

（所以我为什么瓦了啊

``` c++
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; i++)
#define int long long
using namespace std;

typedef long long ll;
const int N = 4e5 + 10, mod = 998244353, G = 3, G1 = 332748118;
int n, m;
int b[N], fa[N], top[N], sz[N], son[N], mx[N];
int to[N << 1], lnk[N], cnt, nxt[N << 1];
int lim, rev[N], id[N], tot, siz[N], dfn[N];
vector<int> f[N][2], g[N][2], zero;
struct node {
    vector<int> f00, f01, f10, f11;
}t;

void add(int x, int y) {
    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;
}

ll quick_pow(ll a, ll b) {
    ll ret = 1;
    for (; b; b >>= 1) {
        if (b & 1) ret = ret * a % mod;
        a = a * a % mod;
    } return ret;
}

void NTT(vector <int> &a, int lim, int op) {
    a.resize(lim);
    rep(i, 0, lim - 1)
        if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int mid = 1; mid < lim; mid <<= 1) {
        int W = quick_pow(op == 1 ? G : G1, (mod - 1) / (mid << 1));
        for (int j = 0; j < lim; j += (mid << 1)) {
            int w = 1;
            for (int k = 0; k < mid; k++, w = 1ll * w * W % mod) {
                int x = a[j + k], y = 1ll * w * a[j + k + mid] % mod;
                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;
            }
        }
    }
    if (op == -1) {
        int Inv = quick_pow(lim, mod - 2);
        rep(i, 0, lim - 1) a[i] = 1ll * a[i] * Inv % mod;
    }
}

void dfs1(int x, int fat) {
    fa[x] = fat;
    sz[x] = 1;
    mx[x] = son[x] = 0;
    for (int i = lnk[x]; i; i = nxt[i]) {
        int y = to[i];
        if (y == fat) continue;
        // printf("%d %d xy\n", x, y);
        dfs1(y, x);
        sz[x] += sz[y];
        mx[x] = max(mx[x], sz[y]);
        if (sz[son[x]] < sz[y]) son[x] = y;
    }
}

void dfs2(int x, int tp) {
    id[++tot] = x, dfn[x] = tot;
    top[x] = tp;
    siz[tp]++;
    if (son[x]) dfs2(son[x], tp);
    for (int i = lnk[x]; i; i = nxt[i]) {
        int y = to[i];
        if (y == fa[x] || y == son[x]) continue;
        dfs2(y, y);
    }
}

vector<int> operator + (vector<int> a, vector<int> b) {
    int sz = max(a.size(), b.size());
    a.resize(sz + 1), b.resize(sz + 1);
    for (int i = 0; i < sz; i++) (a[i] += b[i]) %= mod;
    return a;
}

vector<int> operator - (vector<int> a, vector<int> b) {
    int sz = max(a.size(), b.size());
    a.resize(sz + 1), b.resize(sz + 1);
    for (int i = 0; i < sz; i++) a[i] = (a[i] - b[i] + mod) % mod;
    return a;
}

vector<int> operator * (vector<int> a, vector<int> b) {
    int sz = a.size() + b.size(), lim = 1, l = 0;
    while(lim <= sz) lim <<= 1, ++l;
    rep(i, 1, lim - 1)
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (l - 1));
    vector<int> c; c.clear();
    NTT(a, lim, 1), NTT(b, lim, 1);
    rep(i, 0, lim - 1) c.push_back(a[i] * b[i] % mod);
    NTT(c, lim, -1);
    if (lim > m + 1) c.resize(m + 1), lim = m + 1;
    for (int i = lim - 1; i >= 0; i--) {
        if (!c[i]) c.pop_back(); else break;
    }
    return c;
}

vector<int> calc1(vector<int> *g, int l, int r) {
    if (l == r) return g[l];
    int mid = (l + r) >> 1;
    return calc1(g, l, mid) * calc1(g, mid + 1, r);
}

node calc2(int l, int r) {
    if (l == r) {
        int x = id[l];
        return (node){f[x][0], zero, zero, f[x][1]};
    }
    int mid = (l + r) >> 1;
    node t1 = calc2(l, mid), t2 = calc2(mid + 1, r);
    return (node){
        (t1.f00 + t1.f01) * (t2.f10 + t2.f00) - t1.f01 * t2.f10,  // 0/1 表示链首和链尾取还是不取
        (t1.f00 + t1.f01) * (t2.f11 + t2.f01) - t1.f01 * t2.f11,
        (t1.f10 + t1.f11) * (t2.f00 + t2.f10) - t1.f11 * t2.f10,
        (t1.f10 + t1.f11) * (t2.f01 + t2.f11) - t1.f11 * t2.f11,
    };
}

void solve() {
    for (int i = n; i; --i) {  // 倒序，先做轻儿子们
        int x = id[i];
        if (top[x] == x) {
            rep(j, dfn[x], dfn[x] + siz[x] - 1) {
                int y = id[j];  // y 是重链上的
                int num = 0;
                for (int k = lnk[y]; k; k = nxt[k]) {
                    int z = to[k];
                    if (z == fa[y] || z == son[y]) continue;
                    g[0][++num] = f[z][0] + f[z][1], g[1][num] = f[z][0];  // 把轻儿子合并到 y 上
                }
                if (!num) continue;
                f[y][0] = calc1(g[0], 1, num);  // 分治卷，这样是 log^2 的；一个一个卷就是 n^2 的
                f[y][1] = f[y][1] * calc1(g[1], 1, num);
            }
            node t = calc2(dfn[x], dfn[x] + siz[x] - 1);  // 把链上信息合并到链顶节点
            f[x][0] = t.f01 + t.f00;
            f[x][1] = t.f10 + t.f11;
        }
    }
    f[1][0].resize(m + 1), f[1][1].resize(m + 1);
    // printf("%lld %lld?\n", f[1][0][m], f[1][1][m]);
    printf("%lld\n", (f[1][0][m] + f[1][1][m]) % mod);
}

signed main() {
    cin >> n >> m;
    rep(i, 1, n) {
        scanf("%lld", &b[i]);
        f[i][0].push_back(1);
        f[i][1].push_back(0), f[i][1].push_back(b[i]);
    }
    rep(i, 1, n - 1) {
        int x, y; scanf("%lld%lld", &x, &y);
        add(x, y), add(y, x);
    }
    dfs1(1, 0);
    dfs2(1, 1);
    // rep(i, 1, n) printf("%lld ", siz[i]); puts("");
    solve();
    return 0;
}
```