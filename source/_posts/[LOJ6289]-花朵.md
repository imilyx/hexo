---
title: '[LOJ6289]-èŠ±æœµ'
date: 2020-08-19 20:14:40
tags: 
    - æ ‘é“¾å‰–åˆ†
    - FFT
mathjax: true
---

[ä¼ é€é—¨](https://loj.ac/problem/6289)

çœ‹å®ƒ $id$ è·Ÿæˆ‘ $loj$ $id$ ç›¸åŒå°±åšäº†åš => è°ƒäº† $3h+$ => ä¸è°ƒäº†md 180è¡Œà²¥_à²¥ å…¨ç»™æˆ‘waæ‰æˆ‘ğŸ°äº† 

æœ¬é¢˜çš„ dp æ–¹ç¨‹å¾ˆå¥½æƒ³ï¼š$f[x, 0/1, i]$ è¡¨ç¤º $x$ å­æ ‘é‡Œé€‰äº† $i$ ä¸ªï¼Œ$x$ ä¸é€‰/é€‰çš„å¿«ä¹ç¨‹åº¦å’Œã€‚è¿™æ ·å¤§æ¦‚æ˜¯ $O(n^3)$ çš„ã€‚

å‘ç°åˆå¹¶çš„æ—¶å€™æ˜¯èƒŒåŒ…ï¼Œæƒ³åˆ°å·ç§¯ä¼˜åŒ–ï¼Œ$O(n^2 logn)$ã€‚

è¿˜èƒ½ä¼˜åŒ–ï¼è½»é‡é“¾å‰–åˆ†ï¼Œå…ˆåšè½»å„¿å­å­æ ‘ï¼Œå†æŠŠé‡é“¾ä¸ŠèŠ‚ç‚¹çš„è½»å„¿å­åˆå¹¶åˆ° $fa$ é‚£é‡Œï¼Œå†å¯¹äºæ¯æ¡é‡é“¾æŠŠç­”æ¡ˆåˆå¹¶åˆ°é“¾é¡¶èŠ‚ç‚¹å¤„ï¼Œ$O(nlog^3n)$ã€‚æ³¨æ„åˆå¹¶ç­”æ¡ˆçš„æ—¶å€™åˆ†æ²»åšï¼Œè¿™æ ·æ˜¯ä¸¤åª $log$ çš„ï¼ˆä¸€ä¸ªä¸ªå·å¤ªæ…¢å•¦ï¼ï¼‰

å¤æ‚åº¦åˆ†æå¤§æ¦‚å°±æ˜¯ï¼Œæœ‰ä¸è¶…è¿‡ $log$ æ¡é‡é“¾å’Œ $log$ æ¡è½»é“¾ï¼Œæ¯ä¸ªé‡é“¾é¡¶åšä¸€æ¬¡ä¸¤åª $log$ çš„è½»å„¿å­åˆå¹¶ + å¸¸æ•°æœ‰ç‚¹å°å¤§çš„ä¸¤åª $log$ çš„é“¾ä¿¡æ¯åˆå¹¶ã€‚

é”™è¯¯çš„ä»£ç è´´ä¸€ä»½å§

ï¼ˆæ‰€ä»¥æˆ‘ä¸ºä»€ä¹ˆç“¦äº†å•Š

``` c++
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; i++)
#define int long long
using namespace std;

typedef long long ll;
const int N = 4e5 + 10, mod = 998244353, G = 3, G1 = 332748118;
int n, m;
int b[N], fa[N], top[N], sz[N], son[N], mx[N];
int to[N << 1], lnk[N], cnt, nxt[N << 1];
int lim, rev[N], id[N], tot, siz[N], dfn[N];
vector<int> f[N][2], g[N][2], zero;
struct node {
    vector<int> f00, f01, f10, f11;
}t;

void add(int x, int y) {
    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;
}

ll quick_pow(ll a, ll b) {
    ll ret = 1;
    for (; b; b >>= 1) {
        if (b & 1) ret = ret * a % mod;
        a = a * a % mod;
    } return ret;
}

void NTT(vector <int> &a, int lim, int op) {
    a.resize(lim);
    rep(i, 0, lim - 1)
        if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int mid = 1; mid < lim; mid <<= 1) {
        int W = quick_pow(op == 1 ? G : G1, (mod - 1) / (mid << 1));
        for (int j = 0; j < lim; j += (mid << 1)) {
            int w = 1;
            for (int k = 0; k < mid; k++, w = 1ll * w * W % mod) {
                int x = a[j + k], y = 1ll * w * a[j + k + mid] % mod;
                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;
            }
        }
    }
    if (op == -1) {
        int Inv = quick_pow(lim, mod - 2);
        rep(i, 0, lim - 1) a[i] = 1ll * a[i] * Inv % mod;
    }
}

void dfs1(int x, int fat) {
    fa[x] = fat;
    sz[x] = 1;
    mx[x] = son[x] = 0;
    for (int i = lnk[x]; i; i = nxt[i]) {
        int y = to[i];
        if (y == fat) continue;
        // printf("%d %d xy\n", x, y);
        dfs1(y, x);
        sz[x] += sz[y];
        mx[x] = max(mx[x], sz[y]);
        if (sz[son[x]] < sz[y]) son[x] = y;
    }
}

void dfs2(int x, int tp) {
    id[++tot] = x, dfn[x] = tot;
    top[x] = tp;
    siz[tp]++;
    if (son[x]) dfs2(son[x], tp);
    for (int i = lnk[x]; i; i = nxt[i]) {
        int y = to[i];
        if (y == fa[x] || y == son[x]) continue;
        dfs2(y, y);
    }
}

vector<int> operator + (vector<int> a, vector<int> b) {
    int sz = max(a.size(), b.size());
    a.resize(sz + 1), b.resize(sz + 1);
    for (int i = 0; i < sz; i++) (a[i] += b[i]) %= mod;
    return a;
}

vector<int> operator - (vector<int> a, vector<int> b) {
    int sz = max(a.size(), b.size());
    a.resize(sz + 1), b.resize(sz + 1);
    for (int i = 0; i < sz; i++) a[i] = (a[i] - b[i] + mod) % mod;
    return a;
}

vector<int> operator * (vector<int> a, vector<int> b) {
    int sz = a.size() + b.size(), lim = 1, l = 0;
    while(lim <= sz) lim <<= 1, ++l;
    rep(i, 1, lim - 1)
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (l - 1));
    vector<int> c; c.clear();
    NTT(a, lim, 1), NTT(b, lim, 1);
    rep(i, 0, lim - 1) c.push_back(a[i] * b[i] % mod);
    NTT(c, lim, -1);
    if (lim > m + 1) c.resize(m + 1), lim = m + 1;
    for (int i = lim - 1; i >= 0; i--) {
        if (!c[i]) c.pop_back(); else break;
    }
    return c;
}

vector<int> calc1(vector<int> *g, int l, int r) {
    if (l == r) return g[l];
    int mid = (l + r) >> 1;
    return calc1(g, l, mid) * calc1(g, mid + 1, r);
}

node calc2(int l, int r) {
    if (l == r) {
        int x = id[l];
        return (node){f[x][0], zero, zero, f[x][1]};
    }
    int mid = (l + r) >> 1;
    node t1 = calc2(l, mid), t2 = calc2(mid + 1, r);
    return (node){
        (t1.f00 + t1.f01) * (t2.f10 + t2.f00) - t1.f01 * t2.f10,  // 0/1 è¡¨ç¤ºé“¾é¦–å’Œé“¾å°¾å–è¿˜æ˜¯ä¸å–
        (t1.f00 + t1.f01) * (t2.f11 + t2.f01) - t1.f01 * t2.f11,
        (t1.f10 + t1.f11) * (t2.f00 + t2.f10) - t1.f11 * t2.f10,
        (t1.f10 + t1.f11) * (t2.f01 + t2.f11) - t1.f11 * t2.f11,
    };
}

void solve() {
    for (int i = n; i; --i) {  // å€’åºï¼Œå…ˆåšè½»å„¿å­ä»¬
        int x = id[i];
        if (top[x] == x) {
            rep(j, dfn[x], dfn[x] + siz[x] - 1) {
                int y = id[j];  // y æ˜¯é‡é“¾ä¸Šçš„
                int num = 0;
                for (int k = lnk[y]; k; k = nxt[k]) {
                    int z = to[k];
                    if (z == fa[y] || z == son[y]) continue;
                    g[0][++num] = f[z][0] + f[z][1], g[1][num] = f[z][0];  // æŠŠè½»å„¿å­åˆå¹¶åˆ° y ä¸Š
                }
                if (!num) continue;
                f[y][0] = calc1(g[0], 1, num);  // åˆ†æ²»å·ï¼Œè¿™æ ·æ˜¯ log^2 çš„ï¼›ä¸€ä¸ªä¸€ä¸ªå·å°±æ˜¯ n^2 çš„
                f[y][1] = f[y][1] * calc1(g[1], 1, num);
            }
            node t = calc2(dfn[x], dfn[x] + siz[x] - 1);  // æŠŠé“¾ä¸Šä¿¡æ¯åˆå¹¶åˆ°é“¾é¡¶èŠ‚ç‚¹
            f[x][0] = t.f01 + t.f00;
            f[x][1] = t.f10 + t.f11;
        }
    }
    f[1][0].resize(m + 1), f[1][1].resize(m + 1);
    // printf("%lld %lld?\n", f[1][0][m], f[1][1][m]);
    printf("%lld\n", (f[1][0][m] + f[1][1][m]) % mod);
}

signed main() {
    cin >> n >> m;
    rep(i, 1, n) {
        scanf("%lld", &b[i]);
        f[i][0].push_back(1);
        f[i][1].push_back(0), f[i][1].push_back(b[i]);
    }
    rep(i, 1, n - 1) {
        int x, y; scanf("%lld%lld", &x, &y);
        add(x, y), add(y, x);
    }
    dfs1(1, 0);
    dfs2(1, 1);
    // rep(i, 1, n) printf("%lld ", siz[i]); puts("");
    solve();
    return 0;
}
```