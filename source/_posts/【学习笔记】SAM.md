---
title: '【学习笔记】SAM'
date: 2020-08-10 08:00:40
tags: 
    - SAM
mathjax: true
---

以 备 重 修（我觉得至少还得重修个三四次 QAQ）

[OI-wiki](https://oi-wiki.org/string/sam/)（图片非常清晰直观）

[Flying2018大佬的讲解](https://www.cnblogs.com/Flying2018/p/13444085.html)

几个概念/一点理解：

* $len[u]$ 表示以节点 $u$ 为尾巴的最长路径。也等于它插入时的字符串长度。
* 不恰当的比喻：$SAM$ 的肉体是一棵压缩的 $Trie$ 树，骨架是 $parent$ 树。
* 起点到每个终止节点是一条 $S$ 的后缀，每个节点代表某个长度为 $len[u]$ 的前缀的一些_长度大于某一长度的后缀_。更确切的，$u$ 表示的子串长度是 $(len[fa], len[u]]$ 范围内的。本质不同的子串数等于从起点出发的路径数，也等于 $\sum len[u] - len[fa[u]]$。（$SAM$ 当然是个 $DAG$ 啦
* 根据 $endpos$ 的概念，有祖先关系的节点 $endpos$ 是子集（完全包含）关系，没有祖先关系的节点 endpos 就是不交的。
* 每次加入一个节点最多会增加两个节点，空间复杂度是 $O(n)$ 的。

## $CF1037H$

思路是贪心。

如果 l = 1，r = n，由于要找的是字典序严格大于 T 的，我们考虑找一个 S 的前缀，后面跟一个稍大的字符 ch。用 SAM 求出每一位的 ch，没有的话就是 -1. 最后倒着找第一个不为 -1 的。

考虑 l 和 r 有限制怎么做，增加一步：找 ch 的时候判断 endpos 集合里有无区间 [l, r] 的串。

endpos 集合在这道题里必须求出，我们可以用经典套路——parent树上跑线段树合并。

## $CF700E$

子串啊什么的考虑 SAM。

考虑到 $s_i$ 必然是 $s_{i + 1}$ 的前缀和后缀（不然削掉前/后缀不会更劣），在 parent 树上体现为 $s_i$ 是 $s_{i + 1}$ 的祖先，于是想到 dp，找最长链

怎么判断出现了两次呢？记录任意一个 $s_{i + 1}$ 的位置，endpos 集合用线段树合并，就能查询了。

### [$区间本质不同子串个数$](https://www.luogu.com.cn/problem/P6292)

类似于“区间元素数”，我们离线询问，给每种元素选一个特征点，对于每个右端点维护左端点的答案。具体来说，每次更新以当前位置为右端点的串的 $lstpos$，一个长度为 $T$ 的串对左端点在 $[1, lstpos - T + 1]$ 的询问有贡献。

考虑 $SAM$，区间右端点右移至 $r$ 在 $SAM$ 上就要把一整条路径集合里的子串 $lstpos$ 更改为 $r$。暴力做显然补星。这是个链赋值操作，于是考虑 $LCT$ + $tag$。每个位置 $access$ 后到根的路径上 $lstpos$ 都相同，且代表的子串长度连续（根据 $endpos$ 的定义），可以直接区间修改区间查询。