---
title: '【学习笔记】SAM'
date: 2020-08-10 08:00:40
tags: 
    - SAM
mathjax: true
---

以 备 重 修（我觉得至少还得重修个三四次 QAQ）

[OI-wiki](https://oi-wiki.org/string/sam/)（图片非常清晰直观）

[Flying2018大佬的讲解](https://www.cnblogs.com/Flying2018/p/13444085.html)

几个概念/一点理解：

* SAM 本质是一棵压缩的 Trie 树，起点到每个终止节点是一条 S 的后缀，起点出发的路径数就是本质不同的子串数。
* len[u] 表示以节点 u 为尾巴的最长路径。也等于它插入时的字符串长度。
* 根据 endpos 的概念，有祖先关系的节点 endpos 是子集（完全包含）关系，没有祖先关系的节点 endpos 就是不交的。
* SAM 上每个节点 u 代表的是一个等价类，也是 S 长度为 len[u] 的前缀的一些_长度大于某一长度的后缀_。更确切的，u 表示的子串长度是 (len[fa], len[u]] 范围内的。
* 每次加入一个节点最多会增加两个节点，空间复杂度是 O(n) 的。

然后第二个链接有一些常用技巧。后面见多了会回来写。

## $CF1037H$
-----

思路是贪心。

如果 l = 1，r = n，由于要找的是字典序严格大于 T 的，我们考虑找一个 S 的前缀，后面跟一个稍大的字符 ch。用 SAM 求出每一位的 ch，没有的话就是 -1. 最后倒着找第一个不为 -1 的。

考虑 l 和 r 有限制怎么做，增加一步：找 ch 的时候判断 endpos 集合里有无区间 [l, r] 的串。

endpos 集合在这道题里必须求出，我们可以用经典套路——parent树上跑线段树合并。

## $CF700E$
-----

子串啊什么的考虑 SAM。

考虑到 $s_i$ 必然是 $s_{i + 1}$ 的前缀和后缀（不然削掉前/后缀不会更劣），在 parent 树上体现为 $s_i$ 是 $s_{i + 1}$ 的祖先，于是想到 dp，找最长链

怎么判断出现了两次呢？记录任意一个 $s_{i + 1}$ 的位置，endpos 集合用线段树合并，就能查询了。