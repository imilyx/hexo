---
title: 最短路题目选讲
date: 2018-07-04 14:51:40
tags: 
    - 最短路
mathjax: true
---

### 1. [POJ3662]-Telephone Lines
-------

https://vjudge.net/problem/POJ-3662

题意：在无向图上求一条从 1 到 N 的路径，使得路径上第 K + 1 大的边权尽量小。

本题答案具有单调性，因为边权越大，合法的方案一定包含了边权更小的方案。所以我们可以二分答案，把问题转化为：是否存在一种合法的方案，使得第 K + 1 边权不超过 mid。

转化后，需要把边权大于 mid 的边看作长度为 1 的边，其余看作长度为 0，然后求从 1 到 N 的最短路是否不超过 K 即可。

CODE：
``` c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <iostream>
#include <queue>
using namespace std;

typedef pair<int, int> pii;

int n, p, k, dis[1005];
vector<int> nxt[1005], val[1005];

priority_queue<pii, vector<pii>, greater<pii> > pq;

bool Dijkstra(int limit) {
    memset(dis, 0x3f, sizeof(dis));
    int s = 1;
    dis[s] = 0;
    pq.push(make_pair(dis[s], s));
    while (!pq.empty()) {
        pii u = pq.top();
        pq.pop();
        if (dis[u.second] != u.first) continue;
        int x = u.second;
        for (int i = 0; i < (int)nxt[x].size(); i++) {
            int sum = dis[x] + (val[x][i] >= limit ? 1 : 0);
            if (dis[nxt[x][i]] > sum) {
                dis[nxt[x][i]] = sum;
                pq.push(make_pair(dis[nxt[x][i]], nxt[x][i]));
            }
        }
    }
    return dis[n] >= k + 1;
}

int main() {
    ios::sync_with_stdio(false);
    cin >> n >> p >> k;
    for (int i = 1; i <= p; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        nxt[u].push_back(v);
        nxt[v].push_back(u);
        val[u].push_back(w);
        val[v].push_back(w);
    }
    int l = 0, r = 1000005, ans = -1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (Dijkstra(mid)) l = mid + 1, ans = mid;
        else r = mid - 1;
    }
    if (ans > 1000000) ans = -1;
    if (r < 0) ans = 0;
    printf("%d\n", ans);
    return 0;
}
```


### 2. [CODEVS1173]-最优贸易
-----

http://codevs.cn/problem/1173/

题意：在一张节点带有权值的图上找出一条从 1 到 N 的路径，使得路径上能够选出两个点 p，q（先经过 p 再经过 q），并且“节点 q 的权值减去节点 p 的权值”最大。

图中双向边可以看作两条有向边。我们可以另外建立一幅反图（图中所有边取反，例如原先 u 指向 v，反图中就是 v 指向 u），存在另一个邻接表中。

题中所求其实就是反着走的路上一个权值最大的点和正着走的路上一个权值最小的点。那么我们在正图中正着一遍最短路，反图中反着一遍最短路，求出 D[x] 表示节点 1 到节点 x 的所有路径中权值最小的权值，F[x] 表示节点 N 到节点 x 的所有路径中权值最大的权值。循环一遍求出最大的 F[x] - D[x] 即可。

CODE：
``` c++
#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> pii;

const int N = 1e5 + 5;
vector<int> nxt[N], nxt2[N];
int n, m, price[N], D[N], F[N], vis[N];

priority_queue<pii, vector<pii>, greater<pii> > pq;

void Dijkstra() {
    while (!pq.empty()) {
        pii u = pq.top();
        pq.pop();
        if (D[u.second] != u.first) continue;
        int x = u.second;
        for (int i = 0; i < (int)nxt[x].size(); i++) {
            if (D[nxt[x][i]] > min(D[x], price[nxt[x][i]])) {
                D[nxt[x][i]] = min(D[x], price[nxt[x][i]]);
                pq.push(make_pair(D[nxt[x][i]], nxt[x][i]));
            }
        }
    }
}

void Dijkstra2() {
    while (!pq.empty()) {
        pii u = pq.top();
        pq.pop();
        if (F[u.second] != u.first) continue;
        int x = u.second;
        for (int i = 0; i < (int)nxt2[x].size(); i++) {
            if (F[nxt2[x][i]] < max(F[x], price[nxt2[x][i]])) {
                F[nxt2[x][i]] = max(F[x], price[nxt2[x][i]]);
                pq.push(make_pair(F[nxt2[x][i]], nxt2[x][i]));
            }
        }
    }
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &price[i]);
    for (int i = 1; i <= m; i++) {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        nxt[x].push_back(y), nxt2[y].push_back(x);
        if (z == 2) nxt[y].push_back(x), nxt2[x].push_back(y);
    }

    memset(D, 0x3f, sizeof(D));
    int s = 1;
    D[s] = price[1];
    pq.push(make_pair(D[s], s));
    Dijkstra();

    memset(F, ~0x3f, sizeof(F));
    s = n;
    F[s] = price[n];
    pq.push(make_pair(F[s], s));
    Dijkstra2();

    int ans = 0;
    for (int i = 1; i <= n; i++) {
        ans = max(ans, F[i] - D[i]);
    }
    printf("%d\n", ans);
    return 0;
}
```

### 3. [BZOJ2200]-道路和航线
-----

https://vjudge.net/problem/HYSBZ-2200

题意：最短路，图中带有负权边。

那么只能用SPFA了。题测数据经过特殊构造，无法过。趁机学习一发SLF优化。

CODE：
``` c++
#include <bits/stdc++.h>
using namespace std;

const int N = 25005, INF = (int)1e9;
int T, R, P, S, dis[N];
bool inq[N];
vector<int> nxt[N], val[N];
deque<int> q;  // SLF优化，双端队列

void spfa() {
    for (int i = 1; i <= T; i++) dis[i] = INF;
    q.push_back(S);
    dis[S] = 0;
    inq[S] = 1;
    while (!q.empty()) {
        int u = q.front();
        q.pop_front();
        inq[u] = 0;
        for (int i = 0; i < (int)nxt[u].size(); i++) {
            if (dis[nxt[u][i]] > dis[u] + val[u][i]) {
                dis[nxt[u][i]] = dis[u] + val[u][i];
                if (inq[nxt[u][i]]) continue;
                inq[nxt[u][i]] = 1;
                if (!q.empty()) {
                    if (dis[nxt[u][i]] < dis[q.front()]) q.push_front(nxt[u][i]);
                    else q.push_back(nxt[u][i]);
                }
                else q.push_front(nxt[u][i]);  // q.push_back(nxt[u][i]) 也可以
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin >> T >> R >> P >> S;
    for (int i = 1; i <= R; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        nxt[u].push_back(v);
        nxt[v].push_back(u);
        val[u].push_back(w);
        val[v].push_back(w);
    }
    for (int i = 1; i <= P; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        nxt[u].push_back(v);
        val[u].push_back(w);
    }
    spfa();
    for (int i = 1; i <= T; i++) {
        if (dis[i] == INF) printf("NO PATH\n");
        else printf("%d\n", dis[i]);
    }
    return 0;
}
```