---
title: 'XJOI200807 题解'
date: 2020-08-07 19:07:40
tags: 
    - 比赛
    - 思维
mathjax: true
---

## A
-----

这题就是典型的部分分提醒正解。

01 那部分可以引导想到 bitset，但 $O(q * n / 32)$ 的显然不对，于是想到 $O(q * 2^k / 32)$ 的，即 $f[i, s]$ 表示在第 i 个所在集合 s 中有没有值“扩散”到第 i 个，然后 or 和 and 操作能分别代替 max 和 min 操作，就做完了。

``` c++
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; i++)
using namespace std;

const int N = 1e5 + 10;
int n, K, Q, cnt;
int a[13][N], b[13][N], t[13];
bitset<4096> B[N];

int main() {
    cin >> n >> K >> Q;
    rep(i, 1, K) rep(j, 1, n) scanf("%d", &a[i][j]);
    rep(j, 1, n) {
        rep(i, 1, K) t[i] = a[i][j];
        sort(t + 1, t + K + 1);
        rep(i, 1, K) b[i][j] = t[i];
    }
    rep(s, 0, (1 << K) - 1)
        rep(i, 1, K) if ((s >> (i - 1)) & 1) B[i][s] = 1;
    cnt = K;
    while (Q--) {
        int op, x, y; scanf("%d%d%d", &op, &x, &y);
        if (op == 1) {
            B[++cnt] = (B[x] | B[y]);
        } else if (op == 2) {
            B[++cnt] = (B[x] & B[y]);
        } else {
            for (int j = K; j; --j) {
                int s = 0;
                rep(i, 1, K) if (a[i][y] >= b[j][y]) s |= (1 << (i - 1));
                if (B[x][s]) { printf("%d\n", b[j][y]); break; }
            }
        }
    }
    return 0;
}
```

## B
-----

显然要枚举最终颜色 i。问题抽象成有 s + 1 个点 0 ~ s，当前在 ai，每步可以向左向右或不动，问走到 s 的期望步数，其中在 0 点和 s 点时都是 0。

[题解](https://www.luogu.com.cn/blog/cjyl/solution-cf850f)，等差数列那里还是比较妙的！其实期望题多是从概念出发，我还是概念不清啊。