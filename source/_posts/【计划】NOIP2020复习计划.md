---
title: 'NOIP2020复习计划'
date: 2020-11-10 23:58:59
tags: 
mathjax: true
---

* 相关题目特征
* 算法内容
* 复杂度
* 习题

-----

# *TRICK*

* 中位数相关可考虑二分，将小于二分值的标为 -1，大于二分值的标为 1
* 看见乘积考虑取 log，这样开方就变成除法，乘就变成加法了，有很多优秀的性质
* [快速阶乘算法](https://www.cnblogs.com/gryzy/p/6015485.html)
* 网格图套路一览：C = V - E + F; 分治最短路；二分图染色；笛卡尔树（待补）

-----

# *贪心*
* 区间取点

# *DP*

## 01背包 & 完全背包 & 多重背包

## 数位dp

## 区间dp

## 树型dp

## 概率dp

## 状压dp

## 插头dp

## 斜率优化

## 决策单调性 & 四边形不等式

## 数据结构优化

## 矩阵乘法优化
* 变形：+ 和 max

## wqs 二分

-----

# *图论*

## $A^{*}$ & $IDA^{*}$

## 树
* dfs & 欧拉序 & 括号序列。配合数据结构食用。
* 树的重心 & 直径
* LCA
* 树链剖分 & 长链剖分

## 虚树

## Prufer序列及Cayley定理
* prufer 序列是**无根树**的数列，一棵 $n$ 个点的无根树，prufer 序列长度为 $n - 2$。
* 无根树转数列：找到编号最小的叶子结点，在树上删除它并将它与它相连的点加入 prufer 序列。重复操作直到只剩 2 个点。
* 数列转无根树：每次将 prufer 序列最前面的元素和 当前在树上的且没在 prufer 序列里出现的最小节点 连边。
* Cayley定理：$n$ 个点的**无向完全图**的生成树个数：$n^{n - 2}$
* $n$ 个节点，第 $i$ 个点度为 $d_i$ 的生成树个数：$\frac{(n - 2)!}{\prod\limits_i (d_i - 1)!}$
* $n$ 个节点，$k$ 个连通块，第 $i$ 个块大小是 $a_i$，第 $i$ 个块的度数为 $d_i$，在块之间连 $k - 1$ 条边使得连通的方案数：$n^{k - 2} \times \prod a_i$ [证明](https://oi-wiki.org/graph/prufer/#_3)
* [51nod1601](https://www.luogu.com.cn/paste/jbsz4em1) [CF917D](https://www.luogu.com.cn/paste/8pjpuesx)

## 最小生成树

## kruskal重构树
* [[NOI2018]-归程]() [[APIO2020]-交换城市]()

## tarjan强联通分量
* 有向图里的。定义是任何两个点都能互相到达。
* 强连通分量的基图是边双连通分量，即存在一种给边双分量中的边定向的方案使得其强连通。易证！XD

## tarjan双联通分量

## 割点和桥

## 圆方树

## 基环树
* 分别对树和环处理。
* 扣环：
``` c++
int getlop(int x, int fr) {  // 这里是扣两个点的环，记录的不是 fa 而是来的那条边
    if (vis[x]) { rt = x; return 1; }
    vis[x] = 1;
    for (int i = lnk[x]; i; i = nxt[i]) {
        if ((i >> 1) == fr) continue;
        int y = to[i];
        int t = getlop(y, i >> 1);
        if (t) {
            if (t == 1) {
                lop[++num] = x, dis[num] = val[i], inl[x] = 1;
                if (x != rt) return 1;
            } return 2;
        }
    } return 0;
}
```
* [IOI2008-Island](https://www.luogu.com.cn/problem/P4381), 小清新基环树题，求每棵树的直径之和
* [ARC079D-Namori Grundy](https://www.luogu.com.cn/paste/uc2gqdkt)

## 点分治

## 2-sat
* 有诸多限制，非此即彼的逻辑关系，且是二元关系。
* 拆点做。**考虑要全面**。拓扑序是反的，所以输出答案就是选两者中强连通分量编号较小的，因为在拓扑序上它比较靠后。复杂度和 tarjan 相同，有 $n$ 个点 $m$ 条限制（即边）就是 $O(n + m)$
* [UOJ210](https://www.luogu.com.cn/paste/142viofa)

## 最短路
* spfa & bellman-ford:
* Dijkstra:
* Floyd:
* 差分约束:
* k短路:

## 网络流
* 最大流 = 最小割
* 费用流
* 有上下界的网络流
* 二分图（最大匹配，最大独立集，最大点全覆盖集，最小路径覆盖的一些性质）（匈牙利算法） 

## 欧拉图
* 套圈法

## 拓扑排序

-----

# *数论*

## 埃氏筛 & 线性筛

## 高斯消元

## 行列式

## 原根

## gcd & exgcd

## CRT & exCRT

## 置换

## 欧拉函数

## 概率与期望

## 更相减损术

## 莫比乌斯反演

## 矩阵树定理

## 线性基

## 二项式反演

## 群论 & Burnside & Polya

## 斯特林数

## lucas定理

## 分拆数

-----

# *博弈论*

虽然这个东西在 noip 里几乎不考，但也是很常见（而且我几乎一无所知）的知识点。来系统地整理一下吧。

必胜态转移会到至少一个必败态，必败态一定会到必胜态。终止状态一定是必败态，因此可以考虑分析终止状态的性质。

## bash博弈
* 一堆石子有 n 个，每次最少取 1 个，最多取 m 个。(m + 1) | n 时先手必败，否则先手必胜。

## nim博弈
* n 堆石子，每堆有 a_i 个，每次选择一堆选若干个。XOR(a_i) = 0 则先手必败，否则先手必胜。
* 证明：设 k = XOR(a_i), a_i 为包含 k 最高位的一堆个数，考虑取 $a_i - (a_i\ xor\  k)$ 个使得 a_i 变为 a_i\ xor\ k，这样总的异或和又变为 0。这跟 bash 博弈有异曲同工之妙的就是维持一个稳定态（后手必败态）。

## Wythoff博弈
* 两堆石子，两人轮流从任意一堆中取至少一个或同时从两堆中取同样多的物品，取不到者败。
* 咕咕

## 变形
1. bash + nim。就是在模意义下的 nim 游戏啦，每堆 % 上 (m + 1) 再做 nim。
2. nim-k，每次可以从最多 k 堆石子里拿任意个。结论是把每个位置上的石子数表示成二进制，若每一位上 1 的个数 % (k + 1) 都等于 0 那么先手必败，否则必胜。结论难想但证明还是好胡的。
3. 阶梯博弈，每次可以将一个石子移到它所在阶梯的下一阶梯，位于 0 的石子不能动（石子可以叠起来）。结论是直接做奇数级阶梯的 nim。证明：对手移动奇数位置，就按照 nim 的移法去移；对手移动偶数位置，就顺势把这个石子移到下一个偶数位置。这样就可以视“奇数位置的石子被移动”为“那颗石子没了”，就是普通 nim 了。当然题目不会这么裸，要做转化，比如 [[SDOI2019]-移动金币](https://loj.ac/submission/929939)

## SG
* 万能的存在= =。对于一个游戏，$SG(x) = mex_{y = x.nxt}{SG(y)}$；所有游戏的 SG 异或为 0 时先手必败，否则必胜。

## min-max博弈（搜索） & alpha-beta剪枝

-----

# *数据结构*

## 栈 & 单调栈 & 队列 & 单调队列
* 和区间问题配合食用，可以求出一些范围

## 哈希表

## 并查集
* 路径压缩
* 带权并查集
* 拆点

## 分块

## 莫队
* 根号数据结构嘛。。1e5 内都可做。另外相邻状态能 $O(1)$ 转移。$O(log)$ 要看过不过得去了。。？
* 不带修莫队：记录 $(l, r)$，按$l$ 第一关键字，$r$ 第二关键字排序。换块 $O(n)$，同一个块中 $O(\sqrt{n})$，所以总共 $O(n\sqrt{n})$
* 带修莫队：记录 $(l, r, t)$，$t$ 表示第几次修改，按$l$ 第一关键字，$r$ 第二关键字，$t$ 第三关键字排序，每次若当前修改数比 $t$ 少就将没修改的修改，否则回退。注意如果修改 $(l, r)$ 里的信息要更新答案。复杂度不会分析，视作 $n = m$ 的话，块大小取 $n^{\frac{2}{3}}$ 时有最小值 $n^{\frac{5}{3}}$，所以大约是 $O(n^{\frac{5}{3}} + n\ log\ n)$
* 树上莫队：还是序列问题，将树转化成欧拉序。注意特判 LCA。复杂度分析视作序列问题，带修和不带修复杂度同上⬆
* [[UOJ58]-糖果公园](http://uoj.ac/submission/430504)，一道朴实无华的带修树上莫队（这里采用的是直接跳 LCA + 直接分块，也可以欧拉序）

## bitset

## 树状数组

## 线段树
* lazy-tag
## 线段树合并
* 经常结合树上问题食用，限制就是插入的信息一定得是 O(n) 级别的复杂度才不会错。。来证明一下它 O(nlogn) 的复杂度吧：发现合并两棵线段树的复杂度是它们重合的点数，合并两个点的复杂度是 O(logn)，共合并 n - 1 次所以是 O(nlogn)。
* 除了权值啊下标线段树合并的，还能做 01 trie 合并哦。
* [LOJ3303(01 trie 合并)](https://loj.ac/submission/932042)

* 动态开点
* zkw？
* 主席树

## splay

## 树套树

-----

# *计算几何*

觉得不会考所以只复习凸包（

## 凸包

-----

# *字符串*

这块真是一窍不通 :(

## KMP

## 最小表示法

## Trie 树
* 01 Trie 是 xor 问题的杀手之一。可持久化后可以查询某个区间的异或值。
* [十二省联考2019-异或粽子](https://loj.ac/submission/935085)

## AC自动机

## SA
* 大多是用 $height$ 数组搞事情。（$height[i]$ 表示排名 $i$ 的后缀和排名 $i - 1$ 的后缀的最长公共前缀。）
* 倍增 + 桶排不多说，复杂度 $O(n\ log\ n)$。重点是 $height$ 数组，有结论：$height[rk[i]] >= height[rk[i - 1]] - 1$，近似单调，因此可以 $O(n)$ 求。
* [[NOI2016]-优秀的拆分](https://loj.ac/submission/929295)

## SAM

## manacher

-----

# 其他

## 分治 & 二分 & 三分
* 二分：有单调性的可以二分。[不存在的 BZOJ3580-冒泡排序](https://www.luogu.com.cn/paste/oakm4jh5)
* 01 分数规划：二分比值，注意不等号方向以及取不取的到 '='。[[BJOI2019]-奥术神杖](https://loj.ac/submission/931538)
* 平面分治（平面最近点对）
* cdq 分治
* 整体二分

## 启发式合并

## 哈夫曼编码

## 线性规划

## 朱刘算法

## 爬山

## DLX