---
title: '【置顶】Ideas & Tricks'
date: 2100-00-00 00:00:00
tags: 
mathjax: true
encrypt: true
---

## 杂
---

* 中位数相关可考虑二分，将小于二分值的标为 $-1$，大于二分值的标为 $1$

* 看见乘积考虑取 $log$，这样开方就变成除法，乘就变成加法了，有很多优秀的性质

* 网格图套路一览：$C = V - E + F$; 分治最短路；二分图染色；笛卡尔树；斯坦纳树（待补）

* 得失转换题倒顺序。（$UOJ418$ 等许许多多）

* 某类树上贪心常见题：选了父亲后才能选儿子，要求某些东西最优化。技巧：优的点一定会在父亲被选后立刻被选。堆维护优先级，每次取出队首和父亲所在块合并（如 $UOJ418$ 是放到该块的操作序列末尾）

* **批量**维护删除或加入信息的可以尝试分治，线段树之类的。

* 取 K 个最大对，考虑「超级钢琴」做法。本质是贪心和压缩信息。普通形式是维护指针，被取了就后移，一个道理。

* 小于某个 $limit$ 的操作都被执行，就可以从小往大执行操作。

* 处理区间的套路：固定一维先算，再求和。

* 区间本质不同计数：“特征点”思想，数据结构维护

* 霍尔定理：对于二分图 $G = \{X + Y, E\}$，它存在完美匹配当且仅当 $\forall W \subseteq X, |W| \leq |N_G(W)|$。推论：二分图 $G$ 最大匹配 $= |X| - \max(|W| - |N_G(W)|)$，其中 $W$ 可以为空集。

- 记录一种思维模式：假设答案已经被构造出来，它需要满足什么限制/条件。反向思考。

- 经典模型：有 $sum$ 个物品根据被划分为若干集合，每次可选两个不同集合的物品匹配并抵消。

    考虑 $sum$ 与 $mx$ 的关系。其中 $mx$ 是最大集合大小。$sum - mx \geq mx$ 时能全部匹配，否则不能。

- 经典模型：两个长为 $n$ 的排列 $a$、$b$，每次可交换 $a$ 中两个元素，问最少多少步变成 $b$。

    考虑 $a_i \rightarrow b_i$，构成置换，$ans = n - 循环个数$。

- 皮克定理（计算点阵多边形面积）：$S = a + \frac{b}{2} - 1$，其中 $a$ 为多边形**内部**点数，$b$ 为多边形**格点和边界上**的点数。

- 分治思想：全局问题难搞，限制很多；现在把它划成两半，只要考虑两个集合之间的限制了！（$UOJ604$）

- 不相交路径计数考虑 LGV，LGV 的「边积」加生成函数有奇效，比如某些位置必须被经过多少次之类的，就往经过它的路径边权乘一个 $z$，达到了很好的限制效果。边行列式边卷积显然爆炸，随便什么带进去，最后插回来得到系数。

- 一个不难但是 xml 没想到的 trick= =：矩阵乘法如果求的是矩阵 $A$ 的 $\sum\limits_{i = 0}^n A^i$，建虚的出发点 $s$，连边 $(s, s, 1)$（开头若干次轮空），再连边 $(s, t, 1)$（一步到终点）。

- 用链表将动态加点变成动态删点。（$CF627E-Orchestra$）

- 点数为 n 的无向图，大小为 $\lceil \sqrt{n} \rceil$ 的环和大小为 $\lceil \sqrt{n} \rceil$ 的独立集至少存在一个。（$CF1325F$）

- 主元素法求绝对众数（出现次数 $>$ 总元素个数 $/ 2$）：其余的都被彼此抵消完了
    ``` c++
    cur = a[1];
    cnt = 0;
    rep(i, 1, n)
        if (a[i] == cur) cnt++;
        else {
            if (cnt > 0) cnt--;
            else cur = a[i];
        }
    // 最后的 cur 就是绝对众数
    // 空间 O(1)，时间 O(n)
    ```

- 半平面交对偶转凸包：[大佬](https://trinkle.blog.uoj.ac/blog/235)

## dp & 计数
---

* $dp$ 套 $dp$ 可以看作在一个自动机上暴跑。

* 要在第一项最优的情况下让第二项最优，比如总个数尽量少的情况下总和尽量小，可以把总和加上 $inf$. ($LOJ2977$)

* 用期望做计数题（比较典型的是 $ZJOI2019-线段树$）

* 二进制值域分块，例如高八位和低八位分别在修改和查询时枚举。（$uoj549$）

* 形如 $dp[i] = \sum\limits_{j = 1}^{c_i} dp[i - j * d]$，可以每 $c_i$ 个设置关键点，$O(n)$ 预处理每个块前后缀和，$O(1)$ 查询。

* dp 柿子写出来后信仰 BM。

- 要求父亲颜色 $>$ 儿子的树上填色计数：子树 $x$ 的答案是 $\frac{sz_x!}{\prod\limits_{y \in subtree(x)} sz_y}$

- 填色，要求相邻两个不同色：如果是两三种颜色，考虑分别加，插板法，三种颜色需要考虑先加 A，A 的间隙中有 BCBC(CBCB)、CBC、BCB 三种情况即对 B - C 分别贡献 $0$、$-1$、$+1$，枚举 BCBC 的个数就能算出另外两种的个数。如果颜色很多，就要 dp，留一维表示有多少个间隙需要填，复杂度就 $n^3$ 了……

## 数学
---

* [快速阶乘算法](https://www.cnblogs.com/gryzy/p/6015485.html)

* 生成函数可考虑实际意义

* 面对多项式束手无策，不如把它变成封闭形式搞事情，多项式的加减乘除和数的加减乘除类似的，还可以求导、$ln$、$exp$，多好啊！

* 把 $\prod_{i = l}^{r}$ 变成一个 $r - l + 1$ 次的多项式，就可以 $\sum$ 啦！$\sum$ 就能搞事情啦！

* 容斥系数可 $dp$！可大力优化指数级复杂度到多项式复杂度。

* 期望可用整数概率公式拆分，化计数问题为判定问题，更具体的说，化“恰好”为“至少”，易化了问题。

* 有组合数形式的拆了，元素过大时可考虑下降幂/上升幂形式。

* 看到二维 $FFT$ 别怕，想想先计一维贡献、再计另一维贡献。（$UOJ574$-多线程计算）

* 多项式不一定要 FFT/NTT，可以点值对应位相乘最后插值插回来。（秘密袭击）

* 带删除的线性基（比如动态求 01 矩阵的秩）：[大佬比较详细的解说](https://blog.csdn.net/a_forever_dream/article/details/83654397) 考虑删除向量 $x$ 后我们要尽量找一个来替代 $x$。对线性基里每个向量记录它插入时异或了哪些向量。找到「受本次删除影响」的基外向量 $y$，如果不存在基外的就找基内最低的（这样在删除时就不会影响更低位的向量），把 $y$ 其它受影响的向量异或上 $y$（$y$ 自己变成 $0$，这样就能消除 $x$ 在线性基里的影响，相当于用 $y$ 替代了 $x$）；如果找的是基内的，秩数 $-1$（围绕着我们的圆环）

* 平行求和法

    $\sum\limits_{k \leq n} \binom{r + k}{k} = \binom{n + r + 1}{n}$

    $\sum\limits_{k \leq n} k \binom{r + k}{k} = (r + 1) \binom{n + r + 1}{n - 1}$

    $\sum\limits_{k \leq n} k^2 \binom{r + k}{k} = (r + 1) \binom{n + r + 1}{n - 1} + (r + 1)(r + 2) \binom{n + r + 1}{n - 2}$

* 如何 $O(nlogn)$ 由点值得到系数？设 $f(x) = a_x$，是个 $m$ 次多项式。可以设 $f(x) = \sum\limits_{i = 0}^x \binom{x}{i} s_i$，由 NTT 加速二项式反演得到 $s_i$。（如何优雅地求和）

* $\binom{n}{k} k^{\underline{m}} = \binom{n - m}{k - m} n^{\underline{m}}$

* $(-1)^a = 1 - 2 * (a \% 2) = 1 - 2a + 4 \lfloor \frac{a}{2} \rfloor$

- 生成函数里计算某个修正因子（常数）的值：设 S(F) 表示形式幂级数 F 的系数和，S 依然满足推导的等式。

- 生成函数题要考虑修正因子——当形式幂级数等式两边系数和什么的不相等时就是修正因子出场之时。解修正因子也是根据等式啊系数和之类的解。

- Raney引理：如果 $a_1, \cdots, a_n$ 是一个和为 $1$ 的整数数列，那么 $a$ 的所有循环表示中仅有一种满足所有前缀和为正。画折线图即可证。（《具体数学》p301）

- 一棵 dfs 树，一条非树边和对应的树上路径构成的环是这个环空间的基

- $n$ 个 $[0, 1)$ 数中第 $k$ 大数期望为 $\frac{k}{n + 1}$

- 转置做多点求值的科技：[rqy讲得好赞！](https://rqy.moe/Algorithms/polynomial-evaluation/) ~~在「21Mar」里写了点简化版~~

- 扩展欧拉定理：[大佬的证明](https://blog.csdn.net/ez_yww/article/details/76176970)

- 传统的莫反柿子 $f_n = \sum\limits_{d \mid n} g_d \Rightarrow g_n = \sum\limits_{d \mid n} \mu(\frac{n}{d}) f_d$ 可以看作在质因子集合上 对 $g$ 做高维前缀和 $\Rightarrow$ 对 $f$ 做高维差分。就可以一只 $log$ 算出所有 $f$ 和 $g$ 啦。

## 博弈
---

- 无向点地理问题：

    **问题**：初始时在二分图的一个点上，两人轮流沿着边走，不允许访问重复节点，不能移动者输。

    **结论**：起点 $x$ 先手必胜当且仅当其在所有最大匹配上。

    **必要性**：存在一个最大匹配 $M$ 使得 $x$ 不在其中，与 $x$ 相连的右部点都已匹配，后手每次都有匹配边走，先手必败。

    **充分性**：

        根据增广路定理我们有如下推论：点 x 必然在最大匹配上当且仅当对于每个最大匹配不存在以 x 为一端的偶数长度交替路。

    我们取任意最大匹配 $M$，因为 $x$ 在 $M$ 上且不存在以 $x$ 为一端的偶数长度交替路，从 M 中删去 $x$ 和与其匹配、相邻的边后仍然是最大匹配，此时原先 $x$ 的匹配点是起点，不在 $M'$ 中，转为必要性证明，先手必胜。

    判断 x 在所有最大匹配上的方法：$S$ 到这个点有流量，且 $x$ 不属于源点割集。

    [板题 $LOJ6033$](https://loj.ac/p/6033)

## 图论
---

* 树上路径问题考虑边分治或者点分治 + 堆

* 构造一个排列使得权值最大——用费用流求解。

* 网络流中用连**反向** $\infty$ 边来实现限制。

* 动态维护带权重心：若点权均非负，一棵树可能的带权重心在一条链上，其中深度最小的点是满足「子树点权和严格大于总和一半」的点中深度最大的。因为其子树和大于一半，该树任何一个 dfs 序的带权中位数一定在其子树中。因此找到带权中位数的点后倍增上跳即可。

* BEST 定理：求解有向图欧拉回路个数。设有向图 $G$ 的欧拉回路个数为 $ec(G)$，$t_s(G)$ 表示有向图 $G$ 中以 $s$ 为根的外向树个数。有 $ec_s(G) = t_s(G) \prod (in_x - 1)!$。这里 $in_x$ 显然 $= out_x$。（[$UOJ266$](https://uoj.ac/problem/226)）

    这个定理告诉我们以每个节点为根的外向树个数相等。计算外向树个数可以矩阵树定理。

* 边双连通图就是没有为 $2$ 的点双连通分量的图。因为每一条边都必须在至少一个环中，而这意味着每个边双都被包含在一个更大的点双中。

* 最小割树的定理：用一组最小割将 $S$ 集和 $T$ 集分开，$S$ 中的每个点到 $T$ 中每个点的最小割权值都等于这个最小割权值。于是求最小割树就是随机选两个点跑最小割，建 kruskal 重构树。

- DAG 相关的状压 dp 可考虑分层，每次加入一波度数为 $0$ 的点。

- 矩阵树定理计算边权**和**：边权为 $w_i$ 的边设其边权为 $1 + w_i x$，答案就是行列式的一次项系数。

## 数据结构
---

* 树状数组区间修改区间查询？

    差分, $d_i = a_i - a_{i - 1}, a_i = \sum\limits_{j = 1}^i d_i$

    $$\sum\limits_{i = 1}^x a_i = \sum\limits_{i = 1}^x \sum\limits_{j = 1}^i d_i = \sum\limits_{i = 1}^x d_i * (x - i + 1) = (x + 1) * \sum\limits_{i = 1}^x d_i - \sum\limits_{i = 1}^x d_i * i$$

* 区间问题转二维数点。

- BIT + 倍增：卡常神器，可用来解决「维护前缀和，要求满足某条件的 $lower/upper\_bound$」

- 线段树的奇特写法：查询 $[l, r]$ 信息，从 $[l - 1, l - 1]$ 上跳，沿途若有右子树就计入贡献；从 $[r + 1, r + 1]$ 上跳，沿途若有左子树就计入贡献。这些右子树和左子树拼成了 $[l, r]$。（$ZJOI2017-$线段树）

## 字符串
---

- 将 border 集合中的所有元素排序，最少可以划分成的等差数列个数不超过 $log|S|$ 个。